1.前端操作word
前端使用富文本编辑器；然后获取编辑器的内容，要是带html标签的；通过后台生成word
Java: apache poi
Node:officegen

Office online:
http://view.officeapps.live.com/op/view.aspx?src=
后面那个是具体的文档地址，用URLEncode进行处理的链接地址
通过拼接的地址即可实现office 的在线预览 
需要注意的是：office 在线预览限制
文档访问地址不能直接使用 ip，需要通过域名访问，并且端口必须是 80 端口
文档的格式（必须为以下格式之一）： 
Word：docx、docm、dotm、dotx 
Excel：xlsx、xlsb、xls、xlsm 
PowerPoint：pptx、ppsx、ppt、pps、pptm、potm、ppam、potx、ppsm
文档的大小：Word 和 PowerPoint 文档必须小于 10 兆字节;Excel 必须小于五兆字节（通过office web app 部署的本地服务器可以设置文档大小).


2.UMD的实现很简单，先判断是否支持NodeJS模块格式（exports是否存在），存在则使用NodeJS模块格式。
再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开的全局（window或global）。


3.mac php
mac系统各种一般自带apache服务以及php环境，但是当我们访问本地php页面时会发现php并没有执行而是直接显示源码，这是因为apache服务并没有加载php模块。进行如下的操作就可以解决此问题。
1.在/private/etc/apache2目录下找到并打开httpd.conf文件
2.找到这一行#LoadModule php7_module libexec/apache2/libphp7.so，把前面的#去掉，这里根据电脑里不同的php版本，php7_module这里可能有所变化，所以不要整句复制进行搜索。
3.在终端输入命令：sudo /usr/sbin/apachectl restart 重启apache服务。


4.在ios下iframe内部页面无法自适应
1）包裹一层div,style="overflow: auto;-webkit-overflow-scrolling:touch;width:100%;height:100%;"
2)iframe scrolling="no" width="100%" height="100%"
3)iframe{
        overflow: scroll;
        -webkit-overflow-scrolling: touch;
        min-width: 100%;
        width: 1px;
        *width:100%;
    }


5.echarts折线平滑
贝塞尔曲线路径平滑算法


6.获取width和height
第一种通过内联样式
    var box = document.getElementById('box');
    var w = box.style.width;
    var h = box.style.height;
获取实际的大小
clientWidth和clientHeight
    var w = box.clientWidth;
    var h = box.clientHeight;


7.display: flex;
水平居中
	justify-content: center;
垂直居中
        align-items: center;


8.es6 proxy
proxy(target, handle)会拦截target对象的方法，如：get, set, apply,has等
	    var data = {
                zwj:1
            }

            var p = new Proxy(data,{
                "get":function(target,key,proxy){
                    const today = new Date();
                    console.log(`GET request made for ${key} at ${today}`);
                    console.log("target",target);
                    console.log("key",key);
                    console.log("proxy",proxy);
                    return target[key]
                },
                "set":function (target, key, value, proxy) {
                    console.log("target",target);
                    console.log("key",key);
                    console.log("value",value);
                    console.log("proxy",proxy);

                    target[key] = value
                    return target;
                }
            })

            p.zwj = 3;



9.eslint
vue 子组件报错,如:<template>
配置里添加：
parser: 'vue-eslint-parser',(同rules同级)
npm install babel-eslint --save


10.Html5 hidden属性
它的表现跟CSS的display: none;作用非常相似，元素将会消失，而且不占用任何页面空间。写法很简单：
<div hidden>
	I was hiding
</div>
老式浏览器，不支持这个属性，你可以在CSS里添加下面的代码来支持它：
*[hidden] { display: none; }
注：加上后IE6仍不能支持


11.自动化测试
单元测试
    jest
    Moachi Chai
端到端测试：
    Cypress
    Nightwatch


12.lerna
代码库管理软件


13. MutationObserver
Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。
Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。
var observer = new MutationObserver(function (mutations, observer) {
  mutations.forEach(function(mutation) {
    console.log(mutation);
  });
});
var article = document.querySelector('article');
var  options = {
  'childList': true,
  'attributes':true
};
可选参数 options的属性如下：
childLIst 观察目标节点的子节点的新增和删除。
attributes 观察目标节点的属性节点(新增或删除了某个属性,以及某个属性的属性值发生了变化)。
characterData 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化
subtree 观察目标节点的所有后代节点(观察目标节点所包含的整棵DOM树上的上述三种节点变化)
attributeOldValue 在attributes属性已经设为true的前提下, 将发生变化的属性节点之前的属性值记录下来(记录到下面MutationRecord对象的oldValue属性中)
characterDataOldValue 在characterData属性已经设为true的前提下,将发生变化characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中)
attributeFilter 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些删选参数的话，

observer.observe(article, options);




14.微前端
shadow dom 隔离css
shadow-dom 和 主dom的样式互不影响。
iframe 隔离第三分app

Css modules

应用通信：
URL
浏览器事件总线CustomEvent
通过主通信，使子应用通信



15.Service Worker
javaScript 是单线程的，随着web业务的复杂化，开发者逐渐在js中做了许多耗费资源的运算过程，
这使得单线程的弊端更加凹显。web worker正是基于此被创造出来，它是脱离在主线程之外的，我们可以将复杂耗费时间的事情交给web worker来做。
但是web worker作为一个独立的线程，他的功能应当不仅于此。sw便是在web worker的基础上增加了离线缓存的能力。





16.设计模式和起应用
适配器模式（Adapter）
定义
又名包装器，适配器模式将一个类的接口，转换为客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。
var googleMap = {
    show:function(){
        console.log('开始渲染谷歌地图')
    }
};
var baiduMap = {
    display:function(){
        console.log('开始渲染百度地图')
    }
};
var baidumapAdapter = {
    show : function(){
        return baiduMap.display(); // 一个适配器类使show方法一致
    }
};
renderMap(googleMap);
renderMap(baiduMapAdapter);

策略模式（Strategy）
策略模式定义了算法组，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
一个按不同等级计算年终奖的例子
// 策略组
var strategies = {
    "S": function(salary){
        return salary * 4;
    },
    "A": function(salary){
        return salary * 3;
    },
    "B":function(salary){
        return salary * 2
    }
};
// 内容组
var calculateBonus = function(level,salary){
    return strategies[level](salary);
}
// 执行
console.log(calculateBonus('S',20000)); // 输出：80000


17.窗口化
使数据只有前、当前、后三屏数据。




18.script的crossorigin
 HTML5 新的规定，是可以允许本地获取到跨域脚本的错误信息的，但有两个条件：
 一是跨域脚本的服务器必须通过 Access-Control-Allow-Origin 头信息允许当前域名可以获取错误信息，
 二是网页里的 script 标签也必须指明 src 属性指定的地址是支持跨域的地址，也就是 crossorigin 属性。
   有了这两个条件，就可以获取跨域脚本的错误信息。
   
在html的标签中，有些标签时自带跨域功能的，比如上边提到的audio  img link  script  video 标签，
他们的src属性可以是任意源的链接，并且均可以进行加载。
但是如果在标签中添加了anonymous属性，那么浏览器再去解析这些跨域资源的时候，就不会以它的自带跨域功能去加载了，
而是 使用CORS的方式加载，就像我们的ajax一样，需要服务器设置跨域头，才可以完成加载，否则会报跨域问题，导致加载失败。

