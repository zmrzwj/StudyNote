1.vuetify
安装vue-cli:npm install @vue/cli -g
创建项目：vue create my-app
添加vuetify:  cd my-app;   vue add vuetify

2.自定义配置，需要在项目的 根目录添加一个Vue.config.js
修改vue-cli资源无法正常加载的问题:
vue.config.js中添
module.exports = {
    // 基本路径
    baseUrl: './',
    // 生产环境是否生成 sourceMap 文件
    productionSourceMap: false,
    // 服务器端口号
    // devServer: {
    //     port: 1234,
    // },
}

3.No ESLint configuration found
./node_modules/.bin/eslint --init(前提是先安装eslint：npm install eslint --save-dev)
使用上下键选择eslint的设置。
初始化后会出现.eslintrc.js的文件
module.exports = {
     .....
}

4.dev server使用http-proxy跨域调试
vue.config.js中设置
module.exports = {
    // webpack-dev-server的配置
    devServer: {
        //historyApiFallback: true,
        //hot: true,
        //inline: true,
        //progress: true,
	open:true,//自动打开浏览器
        port: 8080,
        host: '127.0.0.1',
        proxy: {
            '/xs/*': {
                target: 'http://localhost:8889',
                changeOrigin: true,
                secure: false
            }
        }
    },
};

5.vuetify表格
hover的样式
.theme--dark.v-table tbody tr:hover td{
    background: aqua;
    font-weight: bolder;
    color: #ffaf5e;
  }
表格背景：
.zwj-table table.v-table{
    background-color: transparent;
  }


6.vue-cli
vue -V 查看版本
vue create hello-world创建项目
通过上下键选择需要的功能

7.vue-cli3 多页面
新建vue.config.js
// vue.config.js
module.exports = {
    baseUrl: './',
    pages:{
        index:{
            // page 的入口
            entry: 'src/index.js',
            // 模板来源
            template: 'public/index.html',
            // 在 dist/index.html 的输出
            filename: 'index.html',
            // 当使用 title 选项时，
            // template 中的 title 标签需要是 <title><%= htmlWebpackPlugin.options.title %></title>
            title: 'Index Page',
            // 在这个页面中包含的块，默认情况下会包含
            // 提取出来的通用 chunk 和 vendor chunk。
            chunks: ['chunk-vendors', 'chunk-common', 'index']
        },
        home:{
            entry: 'src/home.js',
            template:'public/home.html',
            filename: 'home.html',
            title: 'home Page',
            chunks: ['chunk-vendors', 'chunk-common', 'home']
        }
    }
}
//建议在开发时，新建一个src/pages目录统一管理，页面的 主js,模版html,主vue页面,注意:js,html,vue的名字不要相同，多页面时访问非index.html页面直接http://localhost:8080/home.html


8.Save this as a preset for future projects? (y/N) N 默认选择 No ,表示不把现在的配置设置为本机的默认配置。


9.Linter/Formatter 支持代码风格检查和格式化。

10.socket.io
npm install vue-socket.io --save
在main.js中注册
import VueSocketio from 'vue-socket.io'
Vue.use(VueSocketio, 'http://xxx.xxx.com:2018');//这里的url是后台提供的socket的地址
组件中使用socket
new Vue({
    sockets: {
        connect: function () {
            console.log('socket connected')
        },
        customEmit: function (data) {
            console.log('this method was fired by the socket server. eg: io.emit("customEmit", data)')
        }
    },
    methods: {
        clickButton: function (data) {
            // $socket is socket.io-client instance
            this.$socket.emit('emit_method', data)
        }
    }
})
服务端：
ws.on('connection',(sock)=>{
  sock.on('a',(num1,num2)=>{
    console.log(`${num1},${num2}`)
  })
})

emit命令：
   a）命令可以只有一个名字
　　　　io.emit('自命名')
　　
　　b）命令可以除了名字还有数据
　　　　io.emit('自命名',a)
 
　　c）命令可以除了名字还有多个数据
　　　　io.emit('自命名',a，b，c，...，d)
 
　　d）命令可以除了名字还有回调函数
　　　　io.emit('自命名',data，function(a,b){ } )

on命令：
   a）命令可以只有一个名字
　　　　socket.on('自命名'，function(){ } )
　　
　　b）命令可以除了名字还有数据
　　　　socket.on('自命名',  function(data){  } )
 
　　c）命令可以除了名字还有多个数据
　　　　socket.on('自命名',  function(a,b,c,...,d){  } )
 
　　d）命令可以除了名字数据还有回调函数
　　　　socket.on('自命名',  function(data，fn){  fn(a,b);  })
on是监听某个地址，emit向地址发送数据


11.vue-resource
import VueResource from 'vue-resource'
Vue.use(VueResource)
	this.$http({
            url: '',
            method: 'POST',
            // 请求体重发送的数据
            data: {
                cat: 1
            },
            // 设置请求头
            headers: {
                'Content-Type': 'x-www-from-urlencoded'
            }
        }).then(function () {
            // 请求成功回调
        }, function () {
            // 请求失败回调
        });
vue-resource 提供的便捷方法：
get(url, [data], [options]);
post(url, [data], [options]);
put(url, [data], [options]);
patch(url, [data], [options]);
delete(url, [data], [options]);
jsonp(url, [data], [options]);
   this.$http.post(
    	'http://example.com', 
    	// 请求体重发送数据给服务端
    	{
        	cat: 1,
        	name: 'newBook'
    	},{
        	'headers': {
                'Content-Type': 'x-www-form-urlencoded'
        }
    	}).then(function () {
        	// 成功回调
    	}, function () {
        	// 失败回调
    	});


12.vuex
npm install vex
import Vuex from 'vuex'
Vue.use(Vuex)
export default new Vuex.Store({
  state: {
      count:1
  },
  getters:{
        //到处都需要对count执行，某种操作时，将其写在getters中
	getCount(state){
		return state.count
	}
  },
  mutations: {
      //同步函数
      increment(){
          this.state.count++
      }
  },
  actions: {
      //异步函数处理
      incrementAsync ({ commit }) {
          setTimeout(() => {
              commit('increment')
          }, 1000)
      }
  }
})
在组件使用：this.$store.state.count访问count
调用increment函数：this.$store.commit("increment")
调用incrementAsync函数：this.$store.dispatch("incrementAsync")
调用getCount函数：this.$store.getters.getCount


使用mapState，mapGetters，mapActions
import {mapState,mapGetters,mapActions} from 'vuex'; 
...mapState({//对象展开运算符
    // ...
})

vuex保证只实例化一次：
vuex的install方法：
install(_vue){
	if (vue && vue === _vue) {
		console.log('vuex只能实例化一次')
		return
	}
	
	vue = _vue
}

13.路由懒加载
方法1:
需要plugin-syntax-dynamic-import
npm install --save-dev @babel/plugin-syntax-dynamic-import
const Foo = () => import('./Foo.vue')
或
const Warning = () => import(/* webpackChunkName: "group-Warning" */ './views/Warning');

方法2:
const Expert = resolve => require(['./views/Expert'], resolve);

打包后js文件和css文件都会单独成一个文件


14.图片资源加载
 <img :src="logo"/>
	data(){
            return {
                logo:require("../../assets/logo.png")
            }
        }


15.history模式
history模式需要后台配合
nginx请配置：
location /{
    try_files $uri $uri/ /index.html;
}
try_files 用于按序检测文件是否存在，并返回第一个找到的文件，如果没有就继续往下匹配。
$uri  当用户请求 http://blog.csdn.net/example 时，这里的 $uri 就是 /example。
$uri/，增加了一个 /，也就是看有没有名为 /$root/example/ 的目录。
又找不到，就会到 ry_files的最后一个选项 /index.html，发起一个内部 “子请求”，也就是相当于nginx发起一个 HTTP请求到 http://localhost/index.html。


16.slot
子组件：
<template>
    <div class="example">
        <a-spin tip="Loading..." size="large"/>
    </div>
</template>
<script>
    export default {
        name: "loading",
    }
</script>
父组件：
<Loading v-show="this.$store.state.loadingFlag">
    <div>123</div>
</Loading>
其中的123不会显示，不会编译进Dom
除非在子组件添加<slot></slot>（匿名插槽）

<template>
    <div class="example">
        <a-spin tip="Loading..." size="large"/>
	<slot></slot>
    </div>
</template>
则<div>123</div>会取代子组件的<slot></slot>

具名插槽
<slot name="zwj"></slot>
使用：<div slot=zwj>123</div>

作用域插槽 
我们可以叫它带数据的插槽
匿名插槽
<slot></slot>
具名插槽
<slot name="up"></slot>
作用域插槽要求，在slot上面绑定数据
<slot name="up" :data="data"></slot>
在父组件：
<child>
      <template slot-scope="user">
        <ul>
          <li v-for="item in user.data">{{item}}</li>
        </ul>
      </template>
</child>
使用slot-scope接收子组件的数据


17.vue使用animate.css
npm install animate.css --save
import animate from 'animate.css'
Vue.use(animate)
使用：
    <transition name="fade"
      enter-active-class="zoomIn"
      leave-active-class="zoomOut">
      <img v-show="show" class="animated" src="./assets/logo.png">
    </transition>
注意：class="animated" 必须要
或写出如下形式：
<transition name="fade"
  enter-active-class="animated zoomIn"
  leave-active-class="animated zoomOut">
  <img v-show="show" src="./assets/logo.png">
</transition>
设置延时：
class="animated delay-2s"

多个元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们
<transition
      enter-active-class="slideInRight"
      leave-active-class="slideOutLeft">
      <div id="div1" class="animated"  v-if="index === 1" key="div1">组件1</div>
      <div id="div2" class="animated"  v-else key="div2">组件2</div>
    </transition>

列表过渡
    <transition-group name="list" tag="p"
      enter-active-class="animated rotateInUpLeft"
      leave-active-class="animated rotateOutDownLeft position-absolute">
      <span v-for="item in items" v-bind:key="item" class="list-item">
        {{ item }}
      </span>
    </transition-group>

  /** 方块元素的样式 **/
  .list-item {
    display: inline-block;
    margin-right: 10px;
    background-color: orange;
    width: 30px;
    height: 30px;
    line-height: 30px;
    text-align: center;
    color: #ffffff;
  }
  /** 移除过程中位置固定（确保排序过渡正常） **/
  .position-absolute {
  	position: absolute;
  }
  /*** 元素定位改变时动画 ***/
  .list-move {
	transition: transform 1s;
  }

v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。
transition-group name="list"
使用：.list-move定义v-move

自定义动画时长
<img v-show="show" class="animated fastest" src="./assets/logo.png">
<style>
.animated.fastest {
  -webkit-animation-duration: 200ms;
  animation-duration: 200ms;
}

animate 默认提供了如下 4 个样式来加快或减缓动画的播放：
slow：动画持续 2 秒
slower：动画持续 3 秒
fast：动画持续 800 毫秒
faster：动画持续 500 毫秒


18.export函数
ajax.js
export function ajax(){
}

使用
import {ajax} from "./ajax.js";


19.history模式下请使用“/”,不要再配置“./”了。
不然子路由会跳转错误。


20.vue-router 404页面
const My404 = resolve => require(['./components/404/404'], resolve);
{path:'*',component:My404}


21.添加font-awesome
npm install font-awesome --save
import 'font-awesome/css/font-awesome.min.css'


22.iview
npm install iview --save
import iView from 'iview'
import 'iview/dist/styles/iview.css'
Vue.use(iView)


23.history模式非根目录配置（未验证）
location /test/ {
    alias /test/; // 项目的真实路径,alias 指定的目录名后面一定要加上  "/"
    index index.html;
    try_files $uri $uri/ /test/index.html;
}



24.ant
npm install ant-design-vue --save
import Antd from 'ant-design-vue'
import 'ant-design-vue/dist/antd.css'
Vue.use(Antd)

国际化：
<a-locale-provider :locale="locale">
    <App />
</a-locale-provider>
<script>
import zhCN from 'ant-design-vue/lib/locale-provider/zh_CN';
export default {
  data() {
    return {
      locale: zhCN,
    }
  }
}
</script>




25.vue-cli-service JavaScript heap out of memory
在node_modules下@vue下cli-service下bin下修改vue-cli-service.js
#!/usr/bin/env node 
改为：#!/usr/bin/env node --max_old_space_size=8096


26.eslint ‘no-mutiple-empty-lines’:[1,{'max':2}],//空行不能超过2行

27.mixin
混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。
一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}
// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先
同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。
值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

全局混入
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

自定义选项合并策略
Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  // 返回合并后的值
}


28、vue指令的修饰符
v-model 修饰符
.lazy 指令默认会在 input 事件中加载输入框中的数据,懒加载修饰符之后，只有在输入框失去焦点或者按回车键时才会更新 content 值
.number 修饰符让其转换为 number 类型
.trim 修饰符可以自动过滤掉输入框的首尾空格。

v-on修饰符
.stop - 调用 event.stopPropagation()。
.prevent - 调用 event.preventDefault()。
.capture - 添加事件侦听器时使用 capture 模式。
.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。
.native - 监听组件根元素的原生事件。
.once - 只触发一次回调。
.left - (2.2.0) 只当点击鼠标左键时触发。
.right - (2.2.0) 只当点击鼠标右键时触发。
.middle - (2.2.0) 只当点击鼠标中键时触发。
.passive - (2.3.0) 以 { passive: true } 模式添加侦听器

v-bind修饰符
.sync 是一个语法糖,作用(双向绑定的另一种方式) 
直接在子组件使用this.$emit('update:word', newValue)更新word的值



29.mock.js使用
npm install mockjs --save-dev
在src 目录下创建mock目录 再在mock目录下创建index.js
import Mock from 'mockjs'
let { Random } = Mock
const getdata = function (option) { // 定义请求数据方法
  let datalist = []
  for (let i = 0; i < 20; i += 1) {
    const o = { // mockjs模拟随机生成数据，生成20条
      recipeId: Random.guid(),
      billId: Random.string(10),
      orgId: Random.string('number', 8, 10),
      Date: Random.date('yyyy-MM-dd'),
      time: Random.time('A HH:mm:ss'),
      adress: Random.county(),
      viewName: Random.cword(4, 16), // 随机生成任意名称
      personName: Random.cname(),
      reason: Random.csentence(10, 32)
    }
    datalist.push(o)
  }
  return {
    code: 1,
    msg: '成功',
    data: datalist
  }
}
Mock.mock('/user', /post|get/i, getdata) // 调用模拟数据方法
对带参数的请求：
Mock.mock(RegExp('/user' + '.*'), /post|get/i, getdata)

在main.js引入：
import './mock/index'

使用：
import axios from 'axios'
axios.get('/user').then(res => {})

mockjs它的原理是重写了XMLHttpRequest，它可以在接口没出来时非常方便的模拟数据，上线之后不引用它即可。
window. XMLHttpRequest是可以被覆盖的。






















