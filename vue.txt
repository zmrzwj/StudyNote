1.vuetify
安装vue-cli:npm install @vue/cli -g
创建项目：vue create my-app
添加vuetify:  cd my-app;   vue add vuetify

2.自定义配置，需要在项目的 根目录添加一个Vue.config.js
修改vue-cli资源无法正常加载的问题:
vue.config.js中添
module.exports = {
    // 基本路径
    baseUrl: './',
    // 生产环境是否生成 sourceMap 文件
    productionSourceMap: false,
    // 服务器端口号
    // devServer: {
    //     port: 1234,
    // },
}

3.No ESLint configuration found
./node_modules/.bin/eslint --init(前提是先安装eslint：npm install eslint --save-dev)
使用上下键选择eslint的设置。
初始化后会出现.eslintrc.js的文件
module.exports = {
     .....
}

4.dev server使用http-proxy跨域调试
vue.config.js中设置
module.exports = {
    // webpack-dev-server的配置
    devServer: {
        //historyApiFallback: true,
        //hot: true,
        //inline: true,
        //progress: true,
	open:true,//自动打开浏览器
        port: 8080,
        host: '127.0.0.1',
        proxy: {
            '/xs/*': {
                target: 'http://localhost:8889',
                changeOrigin: true,
                secure: false
            }
        }
    },
};

5.vuetify表格
hover的样式
.theme--dark.v-table tbody tr:hover td{
    background: aqua;
    font-weight: bolder;
    color: #ffaf5e;
  }
表格背景：
.zwj-table table.v-table{
    background-color: transparent;
  }


6.vue-cli
vue -V 查看版本
vue create hello-world创建项目
通过上下键选择需要的功能

7.vue-cli3 多页面
新建vue.config.js
// vue.config.js
module.exports = {
    baseUrl: './',
    pages:{
        index:{
            // page 的入口
            entry: 'src/index.js',
            // 模板来源
            template: 'public/index.html',
            // 在 dist/index.html 的输出
            filename: 'index.html',
            // 当使用 title 选项时，
            // template 中的 title 标签需要是 <title><%= htmlWebpackPlugin.options.title %></title>
            title: 'Index Page',
            // 在这个页面中包含的块，默认情况下会包含
            // 提取出来的通用 chunk 和 vendor chunk。
            chunks: ['chunk-vendors', 'chunk-common', 'index']
        },
        home:{
            entry: 'src/home.js',
            template:'public/home.html',
            filename: 'home.html',
            title: 'home Page',
            chunks: ['chunk-vendors', 'chunk-common', 'home']
        }
    }
}
//建议在开发时，新建一个src/pages目录统一管理，页面的 主js,模版html,主vue页面,注意:js,html,vue的名字不要相同，多页面时访问非index.html页面直接http://localhost:8080/home.html


8.Save this as a preset for future projects? (y/N) N 默认选择 No ,表示不把现在的配置设置为本机的默认配置。


9.Linter/Formatter 支持代码风格检查和格式化。

10.socket.io
npm install vue-socket.io --save
在main.js中注册
import VueSocketio from 'vue-socket.io'
Vue.use(VueSocketio, 'http://xxx.xxx.com:2018');//这里的url是后台提供的socket的地址
组件中使用socket
new Vue({
    sockets: {
        connect: function () {
            console.log('socket connected')
        },
        customEmit: function (data) {
            console.log('this method was fired by the socket server. eg: io.emit("customEmit", data)')
        }
    },
    methods: {
        clickButton: function (data) {
            // $socket is socket.io-client instance
            this.$socket.emit('emit_method', data)
        }
    }
})
服务端：
ws.on('connection',(sock)=>{
  sock.on('a',(num1,num2)=>{
    console.log(`${num1},${num2}`)
  })
})

emit命令：
   a）命令可以只有一个名字
　　　　io.emit('自命名')
　　
　　b）命令可以除了名字还有数据
　　　　io.emit('自命名',a)
 
　　c）命令可以除了名字还有多个数据
　　　　io.emit('自命名',a，b，c，...，d)
 
　　d）命令可以除了名字还有回调函数
　　　　io.emit('自命名',data，function(a,b){ } )

on命令：
   a）命令可以只有一个名字
　　　　socket.on('自命名'，function(){ } )
　　
　　b）命令可以除了名字还有数据
　　　　socket.on('自命名',  function(data){  } )
 
　　c）命令可以除了名字还有多个数据
　　　　socket.on('自命名',  function(a,b,c,...,d){  } )
 
　　d）命令可以除了名字数据还有回调函数
　　　　socket.on('自命名',  function(data，fn){  fn(a,b);  })
on是监听某个地址，emit向地址发送数据


11.vue-resource
import VueResource from 'vue-resource'
Vue.use(VueResource)
	this.$http({
            url: '',
            method: 'POST',
            // 请求体重发送的数据
            data: {
                cat: 1
            },
            // 设置请求头
            headers: {
                'Content-Type': 'x-www-from-urlencoded'
            }
        }).then(function () {
            // 请求成功回调
        }, function () {
            // 请求失败回调
        });
vue-resource 提供的便捷方法：
get(url, [data], [options]);
post(url, [data], [options]);
put(url, [data], [options]);
patch(url, [data], [options]);
delete(url, [data], [options]);
jsonp(url, [data], [options]);
   this.$http.post(
    	'http://example.com', 
    	// 请求体重发送数据给服务端
    	{
        	cat: 1,
        	name: 'newBook'
    	},{
        	'headers': {
                'Content-Type': 'x-www-form-urlencoded'
        }
    	}).then(function () {
        	// 成功回调
    	}, function () {
        	// 失败回调
    	});


12.vuex
npm install vex
import Vuex from 'vuex'
Vue.use(Vuex)
export default new Vuex.Store({
  state: {
      count:1
  },
  getters:{
        //到处都需要对count执行，某种操作时，将其写在getters中
	getCount(state){
		return state.count
	}
  },
  mutations: {
      //同步函数
      increment(){
          this.state.count++
      }
  },
  actions: {
      //异步函数处理
      incrementAsync ({ commit }) {
          setTimeout(() => {
              commit('increment')
          }, 1000)
      }
  }
})
在组件使用：this.$store.state.count访问count
调用increment函数：this.$store.commit("increment")
调用incrementAsync函数：this.$store.dispatch("incrementAsync")
调用getCount函数：this.$store.getters.getCount


使用mapState，mapGetters，mapActions
import {mapState,mapGetters,mapActions} from 'vuex'; 
...mapState({//对象展开运算符
    // ...
})

vuex保证只实例化一次：
vuex的install方法：
install(_vue){
	if (vue && vue === _vue) {
		console.log('vuex只能实例化一次')
		return
	}
	
	vue = _vue
}

13.路由懒加载
方法1:
需要plugin-syntax-dynamic-import
npm install --save-dev @babel/plugin-syntax-dynamic-import
const Foo = () => import('./Foo.vue')
或
const Warning = () => import(/* webpackChunkName: "group-Warning" */ './views/Warning');

方法2:
const Expert = resolve => require(['./views/Expert'], resolve);

打包后js文件和css文件都会单独成一个文件


14.图片资源加载
 <img :src="logo"/>
	data(){
            return {
                logo:require("../../assets/logo.png")
            }
        }


15.history模式
history模式需要后台配合
nginx请配置：
location /{
    try_files $uri $uri/ /index.html;
}
try_files 用于按序检测文件是否存在，并返回第一个找到的文件，如果没有就继续往下匹配。
$uri  当用户请求 http://blog.csdn.net/example 时，这里的 $uri 就是 /example。
$uri/，增加了一个 /，也就是看有没有名为 /$root/example/ 的目录。
又找不到，就会到 ry_files的最后一个选项 /index.html，发起一个内部 “子请求”，也就是相当于nginx发起一个 HTTP请求到 http://localhost/index.html。


16.slot
子组件：
<template>
    <div class="example">
        <a-spin tip="Loading..." size="large"/>
    </div>
</template>
<script>
    export default {
        name: "loading",
    }
</script>
父组件：
<Loading v-show="this.$store.state.loadingFlag">
    <div>123</div>
</Loading>
其中的123不会显示，不会编译进Dom
除非在子组件添加<slot></slot>（匿名插槽）

<template>
    <div class="example">
        <a-spin tip="Loading..." size="large"/>
	<slot></slot>
    </div>
</template>
则<div>123</div>会取代子组件的<slot></slot>

具名插槽
<slot name="zwj"></slot>
使用：<div slot=zwj>123</div>

作用域插槽 
我们可以叫它带数据的插槽
匿名插槽
<slot></slot>
具名插槽
<slot name="up"></slot>
作用域插槽要求，在slot上面绑定数据
<slot name="up" :data="data"></slot>
在父组件：
<child>
      <template slot-scope="user">
        <ul>
          <li v-for="item in user.data">{{item}}</li>
        </ul>
      </template>
</child>
使用slot-scope接收子组件的数据


17.vue使用animate.css
npm install animate.css --save
import animate from 'animate.css'
Vue.use(animate)
使用：
    <transition name="fade"
      enter-active-class="zoomIn"
      leave-active-class="zoomOut">
      <img v-show="show" class="animated" src="./assets/logo.png">
    </transition>
注意：class="animated" 必须要
或写出如下形式：
<transition name="fade"
  enter-active-class="animated zoomIn"
  leave-active-class="animated zoomOut">
  <img v-show="show" src="./assets/logo.png">
</transition>
设置延时：
class="animated delay-2s"

多个元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们
<transition
      enter-active-class="slideInRight"
      leave-active-class="slideOutLeft">
      <div id="div1" class="animated"  v-if="index === 1" key="div1">组件1</div>
      <div id="div2" class="animated"  v-else key="div2">组件2</div>
    </transition>

列表过渡
    <transition-group name="list" tag="p"
      enter-active-class="animated rotateInUpLeft"
      leave-active-class="animated rotateOutDownLeft position-absolute">
      <span v-for="item in items" v-bind:key="item" class="list-item">
        {{ item }}
      </span>
    </transition-group>

  /** 方块元素的样式 **/
  .list-item {
    display: inline-block;
    margin-right: 10px;
    background-color: orange;
    width: 30px;
    height: 30px;
    line-height: 30px;
    text-align: center;
    color: #ffffff;
  }
  /** 移除过程中位置固定（确保排序过渡正常） **/
  .position-absolute {
  	position: absolute;
  }
  /*** 元素定位改变时动画 ***/
  .list-move {
	transition: transform 1s;
  }

v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。
transition-group name="list"
使用：.list-move定义v-move

自定义动画时长
<img v-show="show" class="animated fastest" src="./assets/logo.png">
<style>
.animated.fastest {
  -webkit-animation-duration: 200ms;
  animation-duration: 200ms;
}

animate 默认提供了如下 4 个样式来加快或减缓动画的播放：
slow：动画持续 2 秒
slower：动画持续 3 秒
fast：动画持续 800 毫秒
faster：动画持续 500 毫秒


18.export函数
ajax.js
export function ajax(){
}

使用
import {ajax} from "./ajax.js";


19.history模式下请使用“/”,不要再配置“./”了。
不然子路由会跳转错误。


20.vue-router 404页面
const My404 = resolve => require(['./components/404/404'], resolve);
{path:'*',component:My404}


21.添加font-awesome
npm install font-awesome --save
import 'font-awesome/css/font-awesome.min.css'


22.iview
npm install iview --save
import iView from 'iview'
import 'iview/dist/styles/iview.css'
Vue.use(iView)


23.history模式非根目录配置（未验证）
location /test/ {
    alias /test/; // 项目的真实路径,alias 指定的目录名后面一定要加上  "/"
    index index.html;
    try_files $uri $uri/ /test/index.html;
}



24.ant
npm install ant-design-vue --save
import Antd from 'ant-design-vue'
import 'ant-design-vue/dist/antd.css'
Vue.use(Antd)

国际化：
<a-locale-provider :locale="locale">
    <App />
</a-locale-provider>
<script>
import zhCN from 'ant-design-vue/lib/locale-provider/zh_CN';
export default {
  data() {
    return {
      locale: zhCN,
    }
  }
}
</script>




25.vue-cli-service JavaScript heap out of memory
在node_modules下@vue下cli-service下bin下修改vue-cli-service.js
#!/usr/bin/env node 
改为：#!/usr/bin/env node --max_old_space_size=8096


26.eslint ‘no-mutiple-empty-lines’:[1,{'max':2}],//空行不能超过2行



27.mixin
混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。
一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}
// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先
同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。
值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

全局混入
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

自定义选项合并策略
Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  // 返回合并后的值
}



28、vue指令的修饰符
v-model 修饰符
.lazy 指令默认会在 input 事件中加载输入框中的数据,懒加载修饰符之后，只有在输入框失去焦点或者按回车键时才会更新 content 值
.number 修饰符让其转换为 number 类型
.trim 修饰符可以自动过滤掉输入框的首尾空格。

v-on修饰符
.stop - 调用 event.stopPropagation()。
.prevent - 调用 event.preventDefault()。
.capture - 添加事件侦听器时使用 capture 模式。
.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。
.native - 监听组件根元素的原生事件。
.once - 只触发一次回调。
.left - (2.2.0) 只当点击鼠标左键时触发。
.right - (2.2.0) 只当点击鼠标右键时触发。
.middle - (2.2.0) 只当点击鼠标中键时触发。
.passive - (2.3.0) 以 { passive: true } 模式添加侦听器

v-bind修饰符
.sync 是一个语法糖,作用(双向绑定的另一种方式) 
直接在子组件使用this.$emit('update:word', newValue)更新word的值



29.修改key可以是页面重绘



30.mock.js使用
npm install mockjs --save-dev
在src 目录下创建mock目录 再在mock目录下创建index.js
import Mock from 'mockjs'
let { Random } = Mock
const getdata = function (option) { // 定义请求数据方法
  let datalist = []
  for (let i = 0; i < 20; i += 1) {
    const o = { // mockjs模拟随机生成数据，生成20条
      recipeId: Random.guid(),
      billId: Random.string(10),
      orgId: Random.string('number', 8, 10),
      Date: Random.date('yyyy-MM-dd'),
      time: Random.time('A HH:mm:ss'),
      adress: Random.county(),
      viewName: Random.cword(4, 16), // 随机生成任意名称
      personName: Random.cname(),
      reason: Random.csentence(10, 32)
    }
    datalist.push(o)
  }
  return {
    code: 1,
    msg: '成功',
    data: datalist
  }
}
Mock.mock('/user', /post|get/i, getdata) // 调用模拟数据方法
对带参数的请求：
Mock.mock(RegExp('/user' + '.*'), /post|get/i, getdata)

在main.js引入：
import './mock/index'

使用：
import axios from 'axios'
axios.get('/user').then(res => {})

mockjs它的原理是重写了XMLHttpRequest，它可以在接口没出来时非常方便的模拟数据，上线之后不引用它即可。
window. XMLHttpRequest是可以被覆盖的。




31.vue-cli3修改NODE_ENV
新建文件.env.dev
NODE_ENV=dev
新建.env.prod
NODE_ENV=prod
修改package.json
"scripts": {
    "serve": "vue-cli-service serve --mode dev",
	"build": "vue-cli-service build --mode prod"
 },
 这样使用：process.env.NODE_ENV就得到dev,prod
NODE_ENV默认为‘development’和‘production’
process.env包含2个值：
BASE_URL和NODE_ENV



32.Vue中的动态组件（v-bind:is）的使用及组件传值
<component v-bind:is ="currentTabComponent" :callbackdata="callbackdata"></component>
参数传递和普通组建一样



33.Object.create(null)与{}
使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用.
{}创建时会继承Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。



34.热重载
热重载跟业务无关，是为了让开发更加便捷，不需要频繁刷新重来。


35.
在_init()中有这样的一个执行顺序：其中initState()是在beforeCreate和created之间
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  callHook(vm, 'beforeCreate')
  initInjections(vm) // resolve injections before data/props
  initState(vm) //初始化
  initProvide(vm) // resolve provide after data/props
  callHook(vm, 'created')
initState()做了这些事情：
if (opts.props) initProps(vm, opts.props)//初始化Props
if (opts.methods) initMethods(vm, opts.methods)//初始化methods
if (opts.data) {
  initData(vm)} else {
  observe(vm._data = {}, true /* asRootData */)}//初始化data
if (opts.computed) initComputed(vm, opts.computed)//初始化computed
// immediate: true watch执行(watch执行不一定在computed后)
所以Props，methods,data和computed的初始化都是在beforeCreated和created之间完成的

生命周期：
1）new Vue()
初始化实例属性
实例化的属性既有Vue.js内部需要用到的属性（如vm._watcher），也有提供给外部使用的属性（例如vm.$parent）
以$开发的属性是提供给用户使用的外部属性，以_开头的属性是提供给内部使用的内部属性
Vue.js通过initLifecycle函数向实例中挂载属性，该函数接收Vue.js实例作为参数
2)初始化事件
初始化事件是指将父组件在模板中使用的v-on注册的事件添加到子组件的事件系统
在模板编译阶段，我们会将整个模板编译成渲染函数
Vue.js通过initEvents函数执行初始化事件相关的逻辑
3) beforeCreate至created
进行初始化事件，进行数据的观测
Props，methods,data和computed的初始化
4) created钩子函数和beforeMount间的生命周期
判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)
如果vue实例对象中有template参数选项，则将其作为模板编译成render函数
如果没有template选项，则将外部HTML作为模板编译，template中的模板优先级要高于outer HTML。
（选项中没有template属性，将提取el属性所 指定的DOM节点的outerHTML内容作为模板内容）
render函数选项 > template选项 > outer HTML.
template: new Vue({
    el: '#app',
    template: "<h1>{{message +'这是在template中的'}}</h1>", //在vue配置项中修改的
})
render函数: new Vue({
    el: '#app',
    render: function(createElement) {
        return createElement('h1', 'this is createElement')
    }
})
5）beforeMount与mounted
vue实例对象添加$el成员，并且替换掉挂在的DOM元素
6）beforeUpdate钩子函数和updated钩子函数间的生命周期
当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。
7）beforeDestroy和destroyed钩子函数间的生命周期
beforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。
destroyed钩子函数在Vue 实例销毁后调用。


35.vuex
1）```
new Vue({
    router,
    store,
    render: (h) => h(App),
}).$mount('#app');

render: (h) => h(App)是如下的简写：
render: function (createElement) {
    return createElement(App)
}
new Vue({
    router
})
通过 router 配置参数注入路由，
从而让整个应用都有路由功能
```
2）var index = {
    Store: Store,
    install: install,
    version: '3.1.1',
    mapState: mapState,
    mapMutations: mapMutations,
    mapGetters: mapGetters,
    mapActions: mapActions,
    createNamespacedHelpers: createNamespacedHelpers
  };
  return index;
3）install 函数
install保证vuex只绑定一次
export function install (_Vue) {
  // Vue 已经存在并且相等，说明已经Vuex.use过
  if (Vue && _Vue === Vue) {
    // 省略代码：非生产环境报错，vuex已经安装
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}
4）applyMixin
使最终每个Vue的实例对象，都有一个$store属性。且是同一个Store实例。
怎么做到的呢？Vue.mixin({ beforeCreate: vuexInit });（全局混入）
function vuexInit () {
  // 这里的this指向Vue实例
  var options = this.$options;
  // store injection
  if (options.store) {
    // 存在options.store，就将实例的$store指向Store实例对象。
    this.$store = typeof options.store === 'function'
      ? options.store()
      : options.store;
  } else if (options.parent && options.parent.$store) {
    this.$store = options.parent.$store;
  }
}
this.$options是什么？执行new Vue的时候，其中的参数会被合并到$options中。
5）store
（1）***如果是单页面导入vue，那么如果实例化之前没有Vue.use(Vuex) ,如果是脚本进入挂载在window，vue会自动安装插件***
if (!Vue && typeof window !== 'undefined' && window.Vue) { (当为浏览器引入vuex时)
      install(window.Vue);
    }
（2）// asset 函数实现
export function assert (condition, msg) {
  if (!condition) throw new Error(`[vuex] ${msg}`)
}
条件断言：不满足直接抛出错误
1.必须使用 Vue.use(Vuex) 创建 store 实例。
2.当前环境不支持Promise，报错：vuex 需要 Promise polyfill。
3.Store 函数必须使用 new 操作符调用。

（3）const {
  // 插件默认是空数组
  plugins = [],
  // 严格模式默认是false
  strict = false
} = options
这里就是利用 es6 的结构赋值拿到 options 里的 state，plugins 和 strict。state 表示 rootState，plugins 表示应用的插件、strict 表示是否开启严格模式。
// store internal state
this._options = options
this._committing = false
this._actions = Object.create(null)
this._mutations = Object.create(null)
this._wrappedGetters = Object.create(null)
this._runtimeModules = Object.create(null)
this._subscribers = []
this._watcherVM = new Vue()
这里主要是创建一些内部的属性：
this._options 存储参数 options。
this._committing 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state。
this._actions 用来存储用户定义的所有的 actions。
this._mutations 用来存储用户定义所有的 mutatins。
this._wrappedGetters 用来存储用户定义的所有 getters 。
this._runtimeModules 用来存储所有的运行时的 modules。
this._subscribers 用来存储所有对 mutation 变化的订阅者。
this._watcherVM 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化的。

（4）installModule(this, state, [], this._modules.root)
初始化 根模块。
并且也递归的注册所有子模块。
并且收集所有模块的 getters 放在 this._wrappedGetters 里面。

（5）resetStoreVM(this, state)
初始化 store._vm 响应式的
并且注册 _wrappedGetters 作为 computed 的属性
plugins.forEach(plugin => plugin(this))

（6）// Base data struct for store's module, package with some attribute and method
// store 的模块 基础数据结构，包括一些属性和方法
export default class Module {
  constructor (rawModule, runtime) {
    // 接收参数 runtime
    this.runtime = runtime
    // Store some children item
    // 存储子模块
    this._children = Object.create(null)
    // Store the origin module object which passed by programmer
    // 存储原始未加工的模块
    this._rawModule = rawModule
    // 模块 state
    const rawState = rawModule.state

    // Store the origin module's state
    // 原始Store 可能是函数，也可能是是对象，是假值，则赋值空对象。
    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}
  }
}

（7）installModule 函数
function installModule (store, rootState, path, module, hot) {
  // 是根模块
  const isRoot = !path.length
  // 命名空间 字符串
  const namespace = store._modules.getNamespace(path)
  if (module.namespaced) {
    // 省略代码： 模块命名空间map对象中已经有了，开发环境报错提示重复
    // module 赋值给 _modulesNamespaceMap[namespace]
    store._modulesNamespaceMap[namespace] = module
  }
  // ... 后续代码 移出来 待读解释
}

（8）注册 state
// set state
// 不是根模块且不是热重载
if (!isRoot && !hot) {
  // 获取父级的state
  const parentState = getNestedState(rootState, path.slice(0, -1))
  // 模块名称
  // 比如 cart
  const moduleName = path[path.length - 1]
  // state 注册
  store._withCommit(() => {
    // 省略代码：非生产环境 报错 模块 state 重复设置
    Vue.set(parentState, moduleName, module.state)
  })
}

（9）遍历注册 mutation
module.forEachMutation((mutation, key) => {
  const namespacedType = namespace + key
  registerMutation(store, namespacedType, mutation, local)
})
/**
     * mutations: {
     *    pushProductToCart (state, { id }) {
     *        console.log(state);
     *    }
     * }
     * 也就是为什么用户定义的 mutation 第一个参数是state的原因，第二个参数是payload参数
     */
    handler.call(store, local.state, payload)

（10）遍历注册 action
module.forEachAction((action, key) => {
  const type = action.root ? key : namespace + key
  const handler = action.handler || action
  registerAction(store, type, handler, local)
})
/*为什么用户定义的actions中的函数第一个参数有
     *  { dispatch, commit, getters, state, rootGetters, rootState } 的原因
     * actions: {
     *    checkout ({ commit, state }, products) {
     *        console.log(commit, state);
     *    }
     * }
*/
let res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload)


（11）遍历注册 getter
module.forEachGetter((getter, key) => {
  const namespacedType = namespace + key
  registerGetter(store, namespacedType, getter, local)
})
/**
     * 这也就是为啥 getters 中能获取到  (state, getters, rootState, rootGetters)  这些值的原因
     * getters = {
     *      cartProducts: (state, getters, rootState, rootGetters) => {
     *        console.log(state, getters, rootState, rootGetters);
     *      }
     * }
     */
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )

（12）resetStoreVM(this, state, hot)
// 绑定 store.getter
  store.getters = {}
  // reset local getters cache
  // 重置 本地getters的缓存
  store._makeLocalGettersCache = Object.create(null)
  // 注册时收集的处理后的用户自定义的 wrappedGetters
  const wrappedGetters = store._wrappedGetters
  // 声明 计算属性 computed 对象
  const computed = {}
  // 遍历 wrappedGetters 赋值到 computed 上
  forEachValue(wrappedGetters, (fn, key) => {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    /**
     * partial 函数
     * 执行函数 返回一个新函数
        export function partial (fn, arg) {
          return function () {
            return fn(arg)
          }
        }
     */
    computed[key] = partial(fn, store)
    // getter 赋值 keys
    Object.defineProperty(store.getters, key, {
      get: () => store._vm[key],
      // 可以枚举
      enumerable: true // for local getters
    })
  })

接下来是vuex api
（13）commit
提交 mutation
commit (_type, _payload, _options) {
  // check object-style commit
  // 统一成对象风格
  const {
    type,
    payload,
    options
  } = unifyObjectStyle(_type, _payload, _options)

  const mutation = { type, payload }
  // 取出处理后的用户定义 mutation
  const entry = this._mutations[type]
  // 省略 非生产环境的警告代码 ...
  this._withCommit(() => {
    // 遍历执行
    entry.forEach(function commitIterator (handler) {
      handler(payload)
    })
  })
  // 订阅 mutation 执行
  this._subscribers.forEach(sub => sub(mutation, this.state))
  // 省略 非生产环境的警告代码 ...
}
commit 支持多种方式。比如：
store.commit('increment', {
  count: 10
})
// 对象提交方式
store.commit({
  type: 'increment',
  count: 10

（14）dispatch
分发 action
dispatch (_type, _payload) {
  // check object-style dispatch
  // 获取到type和payload参数
  const {
    type,
    payload
  } = unifyObjectStyle(_type, _payload)

  // 声明 action 变量 等于 type和payload参数
  const action = { type, payload }
  // 入口，也就是 _actions 集合
  const entry = this._actions[type]
  // 省略 非生产环境的警告代码 ...
}

（15）replaceState
替换 store 的根状态，仅用状态合并或时光旅行调试。
replaceState (state) {
  this._withCommit(() => {
    this._vm._data.$$state = state
  })
}

（16）watch
响应式地侦听 fn 的返回值，当值改变时调用回调函数。
/**
 * 观测某个值
 * @param {Function} getter 函数
 * @param {Function} cb 回调
 * @param {Object} options 参数对象
 */
watch (getter, cb, options) {
  if (process.env.NODE_ENV !== 'production') {
    assert(typeof getter === 'function', `store.watch only accepts a function.`)
  }
  return this._watcherVM.$watch(() => getter(this.state, this.getters), cb, options)
}

（17）subscribe
订阅 store 的 mutation。
subscribe (fn) {
  return genericSubscribe(fn, this._subscribers)
}
// 收集订阅者
function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn)
  }
  return () => {
    const i = subs.indexOf(fn)
    if (i > -1) {
      subs.splice(i, 1)
    }
  }
}

（18）subscribeAction
订阅 store 的 action。
subscribeAction (fn) {
  const subs = typeof fn === 'function' ? { before: fn } : fn
  return genericSubscribe(subs, this._actionSubscribers)
}

（19）registerModule
注册一个动态模块。
/**
 * 动态注册模块
 * @param {Array|String} path 路径
 * @param {Object} rawModule 原始未加工的模块
 * @param {Object} options 参数选项
 */
registerModule (path, rawModule, options = {}) {
  // 如果 path 是字符串，转成数组
  if (typeof path === 'string') path = [path]
  // 省略 非生产环境 报错代码
  // 手动调用 模块注册的方法
  this._modules.register(path, rawModule)
  // 安装模块
  installModule(this, this.state, path, this._modules.get(path), options.preserveState)
  // reset store to update getters...
  // 设置 resetStoreVM
  resetStoreVM(this, this.state)
}
unregisterModule
卸载一个动态模块。

（20）hotUpdate
热替换新的 action 和 mutation。
// 热加载
hotUpdate (newOptions) {
  // 调用的是 ModuleCollection 的 update 方法，最终调用对应的是每个 Module 的 update
  this._modules.update(newOptions)
  // 重置 Store
  resetStore(this, true)
}

组件绑定的辅助函数
（21）mapState
为组件创建计算属性以返回 Vuex store 中的状态。
export const mapState = normalizeNamespace((namespace, states) => {
  const res = {}
  // 非生产环境 判断参数 states  必须是数组或者是对象
  if (process.env.NODE_ENV !== 'production' && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object')
  }
  normalizeMap(states).forEach(({ key, val }) => {
    res[key] = function mappedState () {
      let state = this.$store.state
      let getters = this.$store.getters
      // 传了参数 namespace
      if (namespace) {
        // 用 namespace 从 store 中找一个模块。
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        state = module.context.state
        getters = module.context.getters
      }
      // mapState({loginInfo: 'loginInfo'}) mapState(['loginInfo'])
      // mapState({loginInfo: (state, getters)=> {}})
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // 标记为 vuex 方便在 devtools 显示
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
normalizeNamespace 标准化统一命名空间
normalizeMap 标准化统一 map，最终返回的是数组

（22）mapGetters
为组件创建计算属性以返回 getter 的返回值。
export const mapGetters = normalizeNamespace((namespace, getters) => {
  const res = {}
  // 省略代码：非生产环境 判断参数 getters 必须是数组或者是对象
  normalizeMap(getters).forEach(({ key, val }) => {
    // The namespace has been mutated by normalizeNamespace
    val = namespace + val
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      // 省略代码：匹配不到 getter
      return this.$store.getters[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
举例：
computed: {
  ...mapGetters('cart', {
    products: 'cartProducts',
    total: 'cartTotalPrice'
  })
},
最终转换成：
computed: {
  products: this.$store.getters['cart/cartProducts'],
  total: this.$store.getters['cart/cartTotalPrice'],
}

（23）mapActions
创建组件方法分发 action。
export const mapActions = normalizeNamespace((namespace, actions) => {
  const res = {}
  // 省略代码： 非生产环境 判断参数 actions  必须是数组或者是对象
  normalizeMap(actions).forEach(({ key, val }) => {
    res[key] = function mappedAction (...args) {
      // get dispatch function from store
      let dispatch = this.$store.dispatch
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapActions', namespace)
        if (!module) {
          return
        }
        dispatch = module.context.dispatch
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    }
  })
  return res
})

（24）mapMutations
创建组件方法提交 mutation。 mapMutations 和 mapActions 类似，只是 dispatch 换成了 commit。
let commit = this.$store.commit
commit = module.context.commit
return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))





36.vue-router源码解析
1）install 方法做了这麽几件事：
声明一个全局变量 _Vue，用于保存传入的 Vue 然后将其暴露出去，供源码中其他地方使用，这样可以在不将 Vue 打包进源码的前提下随心使用 Vue。
Vue.mixin 全局混入钩子函数（beforeCreate ,destroyed）。
export function initMixin (Vue: GlobalAPI) {
 //mixin 方法，接收一个 Object 类型 mixin 参数
  Vue.mixin = function (mixin: Object) {
    //调用 mergeOptions 将传入的 mixin 对象 合并到 Vue 的 options 上
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
Vue.mixin 中会调用 mergeOptions 这个方法将传入的 mixin 对象通过与 Vue 原有的 options 选项合并成一个新的 option， 然后重新赋给 Vue 的 options 。由于在 Vue 中每个组件的构造函数都会在 extend 阶段合并 Vue.options 到自己的 options 中，这样也就相当于每个组件都定义了 mixin 中定义的选项。所以这也就是通过 Vue.mixin 全局混入的钩子函数会在每一个组件实例初始化的时候被触发调用一次的原因了。

2）class VueRouter
import VueRouter from 'vue-router' 导入的 vue-router 入口文件其实导出的东西就是 VueRouter 这个类。index.js 文件中首先是定义了 vue-router 核心 VueRouter 类，然后是定义了一个注册路由钩子函数的方法和一个创建 href路由跳转路径的方法，下来是将 install 方法挂载给 VueRouter 类的静态 install 方法，最后是一个判断当前运行的浏览器环境的 window 对象上如果挂载了 Vue ,则执行自动安装 vue-router 插件，也就是说只要 import VueRouter from 'vue-router'一执行，上面这些事就会被完成。分析完入口文件被加载时所做的事情后，我们来分析 VueRouter 的实例初始化过程

createMatcher
createMatcher 其实内部就 调用了一个 createRouteMap 方法，这个方法是干嘛的呢，从名字我们就可以猜个差不多，是用来创建路由映射表的一个函数，那辗转又去 createRouteMap 里面吧。
createRouteMap
createRouteMap 方法的功能就是将我们在项目中传入的路由配置（即 new VueRouter({routes,...})中的 routes ）转换成路由映射表,该方法会返回一个对象，对象中包含三个属性，pathList 保存所有的 path； pathMap 保存每个 path 到 RouteRecord 的映射关系；nameMap 保存每个 name 到 RouteRecord 的关系。

3）class History {
    ...
  constructor (router: Router, base: ?string) {
    //将router实例挂载到history实例上
    this.router = router
    //规范化base,如果未配置则给默认值:'/'
    this.base = normalizeBase(base)

    // start with a route object that stands for "nowhere"
    //START: 初始化一个原始current对象（初始化current),项目最开始启动时的current就是这里的START
    /**
     * fullPath: "/"
     * hash: ""
     * matched: []
     * meta: {}
     * name: null
     * params: {}
     * path: "/"
     * query: {}
     */
    this.current = START
   
    this.pending = null
    this.ready = false
    this.readyCbs = []
    this.readyErrorCbs = []
    this.errorCbs = []
  }
}
History 基类的构造函数先将 router (new VueRouter) 实例挂载到 history 实例上，然后对 base 进行规范化（如果未配置则给默认值:'/'），下来初始化一个原始 current 对象（初始化current),这里的 current 初始值 是通过 START 产生的，START 其实是 createRoute 方法用 path = '/'创建的一个 route 对象，也被称为原始 route 对象，这样 current 就拿到了项目初始化（项目启动）时最原始的 route 路由对象，最后初始化了一些内置属性。

4）transitionTo

5) RouteLink
RouteLink 组件首先是可以接收多个 props 选项，其中 to 是必传选型，其余都是可选，默认 tag 标签为 a ，默认触发跳转的事件为 click。该组件渲染也依赖于 render 函数，render 函数中首先拿到 router （$router）实例 和 当前激活态 route 对象（$route）,然后调用 router.resolve() 进行路由解析后取出 location、route、href。（location 表示规范化后的目标 location, route表示通过 match 匹配然后调用 createRoute 生成的最终目标 route，href 表示通过调用 createHref 计算出来的最终要跳转的 href ）
<router-view>是一个渲染函数，它的渲染是用了Vue的 render 函数，它接收两个参数，第一个是Vue实例，第二个是一个context，通过对象解析的方式可以拿到 props、children、parent、data，供创建 <router-view> 使用。
const component = cache[name] = matched.components[name]

6）导航守卫
导航 表示路由正在发生变化，vue-router 提供的导航守卫主要用来通过跳转或者取消的方式守卫导航。导航守卫分为三种：全局守卫、单个路由守卫和组件内的守卫。
全局守卫：
全局前置守卫 beforeEach (to, from, next)
全局解析守卫 beforeResolve (to, from, next)
全局后置钩子 afterEach (to, from)
单个路由守卫：
路由前置守卫 beforeEnter (to, from, next)
组件内的守卫：
渲染组件的对应路由被confirm前 beforeRouterEnter (to, from, next) next可以是函数，因为该守卫不能获取组件实例，新组件还没被创建
路由改变，该组件被复用时调用 (to, from, next)
导航离开该组件对应路由时调用 beforeRouteLeave

router.beforeEach((to, from, next) => {
  // ...
})
每个守卫方法接收三个参数：
to: Route: 即将要进入的目标 路由对象
from: Route: 当前导航正要离开的路由
next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。
next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。
next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。














