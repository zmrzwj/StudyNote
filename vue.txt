1.vuetify
安装vue-cli:npm install @vue/cli -g
创建项目：vue create my-app
添加vuetify:  cd my-app;   vue add vuetify

2.自定义配置，需要在项目的 根目录添加一个Vue.config.js
修改vue-cli资源无法正常加载的问题:
vue.config.js中添
module.exports = {
    // 基本路径
    baseUrl: './',
    // 生产环境是否生成 sourceMap 文件
    productionSourceMap: false,
    // 服务器端口号
    // devServer: {
    //     port: 1234,
    // },
}

3.No ESLint configuration found
./node_modules/.bin/eslint --init(前提是先安装eslint：npm install eslint --save-dev)
使用上下键选择eslint的设置。
初始化后会出现.eslintrc.js的文件
module.exports = {
     .....
}

4.dev server使用http-proxy跨域调试
vue.config.js中设置
module.exports = {
    // webpack-dev-server的配置
    devServer: {
        //historyApiFallback: true,
        //hot: true,
        //inline: true,
        //progress: true,
	open:true,//自动打开浏览器
        port: 8080,
        host: '127.0.0.1',
        proxy: {
            '/xs/*': {
                target: 'http://localhost:8889',
                changeOrigin: true,
                secure: false
            }
        }
    },
};

5.vuetify表格
hover的样式
.theme--dark.v-table tbody tr:hover td{
    background: aqua;
    font-weight: bolder;
    color: #ffaf5e;
  }
表格背景：
.zwj-table table.v-table{
    background-color: transparent;
  }


6.vue-cli
vue -V 查看版本
vue create hello-world创建项目
通过上下键选择需要的功能

7.vue-cli3 多页面
新建vue.config.js
// vue.config.js
module.exports = {
    baseUrl: './',
    pages:{
        index:{
            // page 的入口
            entry: 'src/index.js',
            // 模板来源
            template: 'public/index.html',
            // 在 dist/index.html 的输出
            filename: 'index.html',
            // 当使用 title 选项时，
            // template 中的 title 标签需要是 <title><%= htmlWebpackPlugin.options.title %></title>
            title: 'Index Page',
            // 在这个页面中包含的块，默认情况下会包含
            // 提取出来的通用 chunk 和 vendor chunk。
            chunks: ['chunk-vendors', 'chunk-common', 'index']
        },
        home:{
            entry: 'src/home.js',
            template:'public/home.html',
            filename: 'home.html',
            title: 'home Page',
            chunks: ['chunk-vendors', 'chunk-common', 'home']
        }
    }
}
//建议在开发时，新建一个src/pages目录统一管理，页面的 主js,模版html,主vue页面,注意:js,html,vue的名字不要相同，多页面时访问非index.html页面直接http://localhost:8080/home.html


8.Save this as a preset for future projects? (y/N) N 默认选择 No ,表示不把现在的配置设置为本机的默认配置。


9.Linter/Formatter 支持代码风格检查和格式化。

10.socket.io
npm install vue-socket.io --save
在main.js中注册
import VueSocketio from 'vue-socket.io'
Vue.use(VueSocketio, 'http://xxx.xxx.com:2018');//这里的url是后台提供的socket的地址
组件中使用socket
new Vue({
    sockets: {
        connect: function () {
            console.log('socket connected')
        },
        customEmit: function (data) {
            console.log('this method was fired by the socket server. eg: io.emit("customEmit", data)')
        }
    },
    methods: {
        clickButton: function (data) {
            // $socket is socket.io-client instance
            this.$socket.emit('emit_method', data)
        }
    }
})
服务端：
ws.on('connection',(sock)=>{
  sock.on('a',(num1,num2)=>{
    console.log(`${num1},${num2}`)
  })
})

emit命令：
   a）命令可以只有一个名字
　　　　io.emit('自命名')
　　
　　b）命令可以除了名字还有数据
　　　　io.emit('自命名',a)
 
　　c）命令可以除了名字还有多个数据
　　　　io.emit('自命名',a，b，c，...，d)
 
　　d）命令可以除了名字还有回调函数
　　　　io.emit('自命名',data，function(a,b){ } )

on命令：
   a）命令可以只有一个名字
　　　　socket.on('自命名'，function(){ } )
　　
　　b）命令可以除了名字还有数据
　　　　socket.on('自命名',  function(data){  } )
 
　　c）命令可以除了名字还有多个数据
　　　　socket.on('自命名',  function(a,b,c,...,d){  } )
 
　　d）命令可以除了名字数据还有回调函数
　　　　socket.on('自命名',  function(data，fn){  fn(a,b);  })
on是监听某个地址，emit向地址发送数据


11.vue-resource
import VueResource from 'vue-resource'
Vue.use(VueResource)
	this.$http({
            url: '',
            method: 'POST',
            // 请求体重发送的数据
            data: {
                cat: 1
            },
            // 设置请求头
            headers: {
                'Content-Type': 'x-www-from-urlencoded'
            }
        }).then(function () {
            // 请求成功回调
        }, function () {
            // 请求失败回调
        });
vue-resource 提供的便捷方法：
get(url, [data], [options]);
post(url, [data], [options]);
put(url, [data], [options]);
patch(url, [data], [options]);
delete(url, [data], [options]);
jsonp(url, [data], [options]);
   this.$http.post(
    	'http://example.com', 
    	// 请求体重发送数据给服务端
    	{
        	cat: 1,
        	name: 'newBook'
    	},{
        	'headers': {
                'Content-Type': 'x-www-form-urlencoded'
        }
    	}).then(function () {
        	// 成功回调
    	}, function () {
        	// 失败回调
    	});


12.vuex
npm install vex
import Vuex from 'vuex'
Vue.use(Vuex)
export default new Vuex.Store({
  state: {
      count:1
  },
  getters:{
        //到处都需要对count执行，某种操作时，将其写在getters中
	getCount(state){
		return state.count
	}
  },
  mutations: {
      //同步函数
      increment(){
          this.state.count++
      }
  },
  actions: {
      //异步函数处理
      incrementAsync ({ commit }) {
          setTimeout(() => {
              commit('increment')
          }, 1000)
      }
  }
})
在组件使用：this.$store.state.count访问count
调用increment函数：this.$store.commit("increment")
调用incrementAsync函数：this.$store.dispatch("incrementAsync")
调用getCount函数：this.$store.getters.getCount


使用mapState，mapGetters，mapActions
import {mapState,mapGetters,mapActions} from 'vuex'; 
...mapState({//对象展开运算符
    // ...
})

vuex保证只实例化一次：
vuex的install方法：
install(_vue){
	if (vue && vue === _vue) {
		console.log('vuex只能实例化一次')
		return
	}
	
	vue = _vue
}

13.路由懒加载
方法1:
需要plugin-syntax-dynamic-import
npm install --save-dev @babel/plugin-syntax-dynamic-import
const Foo = () => import('./Foo.vue')
或
const Warning = () => import(/* webpackChunkName: "group-Warning" */ './views/Warning');

方法2:
const Expert = resolve => require(['./views/Expert'], resolve);

打包后js文件和css文件都会单独成一个文件


14.图片资源加载
 <img :src="logo"/>
	data(){
            return {
                logo:require("../../assets/logo.png")
            }
        }


15.history模式
history模式需要后台配合
nginx请配置：
location /{
    try_files $uri $uri/ /index.html;
}
try_files 用于按序检测文件是否存在，并返回第一个找到的文件，如果没有就继续往下匹配。
$uri  当用户请求 http://blog.csdn.net/example 时，这里的 $uri 就是 /example。
$uri/，增加了一个 /，也就是看有没有名为 /$root/example/ 的目录。
又找不到，就会到 ry_files的最后一个选项 /index.html，发起一个内部 “子请求”，也就是相当于nginx发起一个 HTTP请求到 http://localhost/index.html。


16.slot
子组件：
<template>
    <div class="example">
        <a-spin tip="Loading..." size="large"/>
    </div>
</template>
<script>
    export default {
        name: "loading",
    }
</script>
父组件：
<Loading v-show="this.$store.state.loadingFlag">
    <div>123</div>
</Loading>
其中的123不会显示，不会编译进Dom
除非在子组件添加<slot></slot>（匿名插槽）

<template>
    <div class="example">
        <a-spin tip="Loading..." size="large"/>
	<slot></slot>
    </div>
</template>
则<div>123</div>会取代子组件的<slot></slot>

具名插槽
<slot name="zwj"></slot>
使用：<div slot=zwj>123</div>

作用域插槽 
我们可以叫它带数据的插槽
匿名插槽
<slot></slot>
具名插槽
<slot name="up"></slot>
作用域插槽要求，在slot上面绑定数据
<slot name="up" :data="data"></slot>
在父组件：
<child>
      <template slot-scope="user">
        <ul>
          <li v-for="item in user.data">{{item}}</li>
        </ul>
      </template>
</child>
使用slot-scope接收子组件的数据


17.vue使用animate.css
npm install animate.css --save
import animate from 'animate.css'
Vue.use(animate)
使用：
    <transition name="fade"
      enter-active-class="zoomIn"
      leave-active-class="zoomOut">
      <img v-show="show" class="animated" src="./assets/logo.png">
    </transition>
注意：class="animated" 必须要
或写出如下形式：
<transition name="fade"
  enter-active-class="animated zoomIn"
  leave-active-class="animated zoomOut">
  <img v-show="show" src="./assets/logo.png">
</transition>
设置延时：
class="animated delay-2s"

多个元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们
<transition
      enter-active-class="slideInRight"
      leave-active-class="slideOutLeft">
      <div id="div1" class="animated"  v-if="index === 1" key="div1">组件1</div>
      <div id="div2" class="animated"  v-else key="div2">组件2</div>
    </transition>

列表过渡
    <transition-group name="list" tag="p"
      enter-active-class="animated rotateInUpLeft"
      leave-active-class="animated rotateOutDownLeft position-absolute">
      <span v-for="item in items" v-bind:key="item" class="list-item">
        {{ item }}
      </span>
    </transition-group>

  /** 方块元素的样式 **/
  .list-item {
    display: inline-block;
    margin-right: 10px;
    background-color: orange;
    width: 30px;
    height: 30px;
    line-height: 30px;
    text-align: center;
    color: #ffffff;
  }
  /** 移除过程中位置固定（确保排序过渡正常） **/
  .position-absolute {
  	position: absolute;
  }
  /*** 元素定位改变时动画 ***/
  .list-move {
	transition: transform 1s;
  }

v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。
transition-group name="list"
使用：.list-move定义v-move

自定义动画时长
<img v-show="show" class="animated fastest" src="./assets/logo.png">
<style>
.animated.fastest {
  -webkit-animation-duration: 200ms;
  animation-duration: 200ms;
}

animate 默认提供了如下 4 个样式来加快或减缓动画的播放：
slow：动画持续 2 秒
slower：动画持续 3 秒
fast：动画持续 800 毫秒
faster：动画持续 500 毫秒


18.export函数
ajax.js
export function ajax(){
}

使用
import {ajax} from "./ajax.js";


19.history模式下请使用“/”,不要再配置“./”了。
不然子路由会跳转错误。


20.vue-router 404页面
const My404 = resolve => require(['./components/404/404'], resolve);
{path:'*',component:My404}


21.添加font-awesome
npm install font-awesome --save
import 'font-awesome/css/font-awesome.min.css'


22.iview
npm install iview --save
import iView from 'iview'
import 'iview/dist/styles/iview.css'
Vue.use(iView)


23.history模式非根目录配置（未验证）
location /test/ {
    alias /test/; // 项目的真实路径,alias 指定的目录名后面一定要加上  "/"
    index index.html;
    try_files $uri $uri/ /test/index.html;
}



24.ant
npm install ant-design-vue --save
import Antd from 'ant-design-vue'
import 'ant-design-vue/dist/antd.css'
Vue.use(Antd)

国际化：
<a-locale-provider :locale="locale">
    <App />
</a-locale-provider>
<script>
import zhCN from 'ant-design-vue/lib/locale-provider/zh_CN';
export default {
  data() {
    return {
      locale: zhCN,
    }
  }
}
</script>




25.vue-cli-service JavaScript heap out of memory
在node_modules下@vue下cli-service下bin下修改vue-cli-service.js
#!/usr/bin/env node 
改为：#!/usr/bin/env node --max_old_space_size=8096


26.eslint ‘no-mutiple-empty-lines’:[1,{'max':2}],//空行不能超过2行



27.mixin
混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。
一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}
// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先
同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。
值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

全局混入
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

自定义选项合并策略
Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  // 返回合并后的值
}



28、vue指令的修饰符
v-model 修饰符
.lazy 指令默认会在 input 事件中加载输入框中的数据,懒加载修饰符之后，只有在输入框失去焦点或者按回车键时才会更新 content 值
.number 修饰符让其转换为 number 类型
.trim 修饰符可以自动过滤掉输入框的首尾空格。

v-on修饰符
.stop - 调用 event.stopPropagation()。
.prevent - 调用 event.preventDefault()。
.capture - 添加事件侦听器时使用 capture 模式。
.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。
.native - 监听组件根元素的原生事件。
.once - 只触发一次回调。
.left - (2.2.0) 只当点击鼠标左键时触发。
.right - (2.2.0) 只当点击鼠标右键时触发。
.middle - (2.2.0) 只当点击鼠标中键时触发。
.passive - (2.3.0) 以 { passive: true } 模式添加侦听器

v-bind修饰符
.sync 是一个语法糖,作用(双向绑定的另一种方式) 
直接在子组件使用this.$emit('update:word', newValue)更新word的值
父组件：
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
简写就是：<text-document v-bind:title.sync="doc.title"></text-document>



29.修改key可以是页面重绘



30.mock.js使用
npm install mockjs --save-dev
在src 目录下创建mock目录 再在mock目录下创建index.js
import Mock from 'mockjs'
let { Random } = Mock
const getdata = function (option) { // 定义请求数据方法
  let datalist = []
  for (let i = 0; i < 20; i += 1) {
    const o = { // mockjs模拟随机生成数据，生成20条
      recipeId: Random.guid(),
      billId: Random.string(10),
      orgId: Random.string('number', 8, 10),
      Date: Random.date('yyyy-MM-dd'),
      time: Random.time('A HH:mm:ss'),
      adress: Random.county(),
      viewName: Random.cword(4, 16), // 随机生成任意名称
      personName: Random.cname(),
      reason: Random.csentence(10, 32)
    }
    datalist.push(o)
  }
  return {
    code: 1,
    msg: '成功',
    data: datalist
  }
}
Mock.mock('/user', /post|get/i, getdata) // 调用模拟数据方法
对带参数的请求：
Mock.mock(RegExp('/user' + '.*'), /post|get/i, getdata)

在main.js引入：
import './mock/index'

使用：
import axios from 'axios'
axios.get('/user').then(res => {})

mockjs它的原理是重写了XMLHttpRequest，它可以在接口没出来时非常方便的模拟数据，上线之后不引用它即可。
window. XMLHttpRequest是可以被覆盖的。




31.vue-cli3修改NODE_ENV
新建文件.env.dev
NODE_ENV=dev
新建.env.prod
NODE_ENV=prod
修改package.json
"scripts": {
    "serve": "vue-cli-service serve --mode dev",
	"build": "vue-cli-service build --mode prod"
 },
 这样使用：process.env.NODE_ENV就得到dev,prod
NODE_ENV默认为‘development’和‘production’
process.env包含2个值：
BASE_URL和NODE_ENV



32.Vue中的动态组件（v-bind:is）的使用及组件传值
<component v-bind:is ="currentTabComponent" :callbackdata="callbackdata"></component>
参数传递和普通组建一样



33.Object.create(null)与{}
使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用.
{}创建时会继承Object自身的方法，如hasOwnProperty、toString等，在新对象上可以直接使用。



34.热重载
热重载跟业务无关，是为了让开发更加便捷，不需要频繁刷新重来。


35._init()执行顺序
在_init()中有这样的一个执行顺序：其中initState()是在beforeCreate和created之间
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  callHook(vm, 'beforeCreate')
  initInjections(vm) // resolve injections before data/props
  initState(vm) //初始化
  initProvide(vm) // resolve provide after data/props
  callHook(vm, 'created')
initState()做了这些事情：
if (opts.props) initProps(vm, opts.props)//初始化Props
if (opts.methods) initMethods(vm, opts.methods)//初始化methods
if (opts.data) {
  initData(vm)} else {
  observe(vm._data = {}, true /* asRootData */)}//初始化data
if (opts.computed) initComputed(vm, opts.computed)//初始化computed
// immediate: true watch执行(watch执行不一定在computed后)
所以Props，methods,data和computed的初始化都是在beforeCreated和created之间完成的

生命周期：
1）new Vue()
初始化实例属性
实例化的属性既有Vue.js内部需要用到的属性（如vm._watcher），也有提供给外部使用的属性（例如vm.$parent）
以$开发的属性是提供给用户使用的外部属性，以_开头的属性是提供给内部使用的内部属性
Vue.js通过initLifecycle函数向实例中挂载属性，该函数接收Vue.js实例作为参数
2)初始化事件
初始化事件是指将父组件在模板中使用的v-on注册的事件添加到子组件的事件系统
在模板编译阶段，我们会将整个模板编译成渲染函数
Vue.js通过initEvents函数执行初始化事件相关的逻辑
3) beforeCreate至created
进行初始化事件，进行数据的观测
Props，methods,data和computed的初始化
4) created钩子函数和beforeMount间的生命周期
判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)
如果vue实例对象中有template参数选项，则将其作为模板编译成render函数
如果没有template选项，则将外部HTML作为模板编译，template中的模板优先级要高于outer HTML。
（选项中没有template属性，将提取el属性所 指定的DOM节点的outerHTML内容作为模板内容）
render函数选项 > template选项 > outer HTML.
template: new Vue({
    el: '#app',
    template: "<h1>{{message +'这是在template中的'}}</h1>", //在vue配置项中修改的
})
render函数: new Vue({
    el: '#app',
    render: function(createElement) {
        return createElement('h1', 'this is createElement')
    }
})
5）beforeMount与mounted
vue实例对象添加$el成员，并且替换掉挂在的DOM元素
6）beforeUpdate钩子函数和updated钩子函数间的生命周期
当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。
7）beforeDestroy和destroyed钩子函数间的生命周期
beforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。
destroyed钩子函数在Vue 实例销毁后调用。


35.vuex
1）```
new Vue({
    router,
    store,
    render: (h) => h(App),
}).$mount('#app');

render: (h) => h(App)是如下的简写：
render: function (createElement) {
    return createElement(App)
}
new Vue({
    router
})
通过 router 配置参数注入路由，
从而让整个应用都有路由功能
```
2）var index = {
    Store: Store,
    install: install,
    version: '3.1.1',
    mapState: mapState,
    mapMutations: mapMutations,
    mapGetters: mapGetters,
    mapActions: mapActions,
    createNamespacedHelpers: createNamespacedHelpers
  };
  return index;
3）install 函数
install保证vuex只绑定一次
export function install (_Vue) {
  // Vue 已经存在并且相等，说明已经Vuex.use过
  if (Vue && _Vue === Vue) {
    // 省略代码：非生产环境报错，vuex已经安装
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}
4）applyMixin
使最终每个Vue的实例对象，都有一个$store属性。且是同一个Store实例。
怎么做到的呢？Vue.mixin({ beforeCreate: vuexInit });（全局混入）
function vuexInit () {
  // 这里的this指向Vue实例
  var options = this.$options;
  // store injection
  if (options.store) {
    // 存在options.store，就将实例的$store指向Store实例对象。
    this.$store = typeof options.store === 'function'
      ? options.store()
      : options.store;
  } else if (options.parent && options.parent.$store) {
    this.$store = options.parent.$store;
  }
}
this.$options是什么？执行new Vue的时候，其中的参数会被合并到$options中。
5）store
（1）***如果是单页面导入vue，那么如果实例化之前没有Vue.use(Vuex) ,如果是脚本进入挂载在window，vue会自动安装插件***
if (!Vue && typeof window !== 'undefined' && window.Vue) { (当为浏览器引入vuex时)
      install(window.Vue);
    }
（2）// asset 函数实现
export function assert (condition, msg) {
  if (!condition) throw new Error(`[vuex] ${msg}`)
}
条件断言：不满足直接抛出错误
1.必须使用 Vue.use(Vuex) 创建 store 实例。
2.当前环境不支持Promise，报错：vuex 需要 Promise polyfill。
3.Store 函数必须使用 new 操作符调用。

（3）const {
  // 插件默认是空数组
  plugins = [],
  // 严格模式默认是false
  strict = false
} = options
这里就是利用 es6 的结构赋值拿到 options 里的 state，plugins 和 strict。state 表示 rootState，plugins 表示应用的插件、strict 表示是否开启严格模式。
// store internal state
this._options = options
this._committing = false
this._actions = Object.create(null)
this._mutations = Object.create(null)
this._wrappedGetters = Object.create(null)
this._runtimeModules = Object.create(null)
this._subscribers = []
this._watcherVM = new Vue()
这里主要是创建一些内部的属性：
this._options 存储参数 options。
this._committing 标志一个提交状态，作用是保证对 Vuex 中 state 的修改只能在 mutation 的回调函数中，而不能在外部随意修改 state。
this._actions 用来存储用户定义的所有的 actions。
this._mutations 用来存储用户定义所有的 mutatins。
this._wrappedGetters 用来存储用户定义的所有 getters 。
this._runtimeModules 用来存储所有的运行时的 modules。
this._subscribers 用来存储所有对 mutation 变化的订阅者。
this._watcherVM 是一个 Vue 对象的实例，主要是利用 Vue 实例方法 $watch 来观测变化的。

（4）installModule(this, state, [], this._modules.root)
初始化 根模块。
并且也递归的注册所有子模块。
并且收集所有模块的 getters 放在 this._wrappedGetters 里面。

（5）resetStoreVM(this, state)
初始化 store._vm 响应式的
并且注册 _wrappedGetters 作为 computed 的属性
plugins.forEach(plugin => plugin(this))

（6）// Base data struct for store's module, package with some attribute and method
// store 的模块 基础数据结构，包括一些属性和方法
export default class Module {
  constructor (rawModule, runtime) {
    // 接收参数 runtime
    this.runtime = runtime
    // Store some children item
    // 存储子模块
    this._children = Object.create(null)
    // Store the origin module object which passed by programmer
    // 存储原始未加工的模块
    this._rawModule = rawModule
    // 模块 state
    const rawState = rawModule.state

    // Store the origin module's state
    // 原始Store 可能是函数，也可能是是对象，是假值，则赋值空对象。
    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}
  }
}

（7）installModule 函数
function installModule (store, rootState, path, module, hot) {
  // 是根模块
  const isRoot = !path.length
  // 命名空间 字符串
  const namespace = store._modules.getNamespace(path)
  if (module.namespaced) {
    // 省略代码： 模块命名空间map对象中已经有了，开发环境报错提示重复
    // module 赋值给 _modulesNamespaceMap[namespace]
    store._modulesNamespaceMap[namespace] = module
  }
  // ... 后续代码 移出来 待读解释
}

（8）注册 state
// set state
// 不是根模块且不是热重载
if (!isRoot && !hot) {
  // 获取父级的state
  const parentState = getNestedState(rootState, path.slice(0, -1))
  // 模块名称
  // 比如 cart
  const moduleName = path[path.length - 1]
  // state 注册
  store._withCommit(() => {
    // 省略代码：非生产环境 报错 模块 state 重复设置
    Vue.set(parentState, moduleName, module.state)
  })
}

（9）遍历注册 mutation
module.forEachMutation((mutation, key) => {
  const namespacedType = namespace + key
  registerMutation(store, namespacedType, mutation, local)
})
/**
     * mutations: {
     *    pushProductToCart (state, { id }) {
     *        console.log(state);
     *    }
     * }
     * 也就是为什么用户定义的 mutation 第一个参数是state的原因，第二个参数是payload参数
     */
    handler.call(store, local.state, payload)

（10）遍历注册 action
module.forEachAction((action, key) => {
  const type = action.root ? key : namespace + key
  const handler = action.handler || action
  registerAction(store, type, handler, local)
})
/*为什么用户定义的actions中的函数第一个参数有
     *  { dispatch, commit, getters, state, rootGetters, rootState } 的原因
     * actions: {
     *    checkout ({ commit, state }, products) {
     *        console.log(commit, state);
     *    }
     * }
*/
let res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload)


（11）遍历注册 getter
module.forEachGetter((getter, key) => {
  const namespacedType = namespace + key
  registerGetter(store, namespacedType, getter, local)
})
/**
     * 这也就是为啥 getters 中能获取到  (state, getters, rootState, rootGetters)  这些值的原因
     * getters = {
     *      cartProducts: (state, getters, rootState, rootGetters) => {
     *        console.log(state, getters, rootState, rootGetters);
     *      }
     * }
     */
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )

（12）resetStoreVM(this, state, hot)
// 绑定 store.getter
  store.getters = {}
  // reset local getters cache
  // 重置 本地getters的缓存
  store._makeLocalGettersCache = Object.create(null)
  // 注册时收集的处理后的用户自定义的 wrappedGetters
  const wrappedGetters = store._wrappedGetters
  // 声明 计算属性 computed 对象
  const computed = {}
  // 遍历 wrappedGetters 赋值到 computed 上
  forEachValue(wrappedGetters, (fn, key) => {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    /**
     * partial 函数
     * 执行函数 返回一个新函数
        export function partial (fn, arg) {
          return function () {
            return fn(arg)
          }
        }
     */
    computed[key] = partial(fn, store)
    // getter 赋值 keys
    Object.defineProperty(store.getters, key, {
      get: () => store._vm[key],
      // 可以枚举
      enumerable: true // for local getters
    })
  })

接下来是vuex api
（13）commit
提交 mutation
commit (_type, _payload, _options) {
  // check object-style commit
  // 统一成对象风格
  const {
    type,
    payload,
    options
  } = unifyObjectStyle(_type, _payload, _options)

  const mutation = { type, payload }
  // 取出处理后的用户定义 mutation
  const entry = this._mutations[type]
  // 省略 非生产环境的警告代码 ...
  this._withCommit(() => {
    // 遍历执行
    entry.forEach(function commitIterator (handler) {
      handler(payload)
    })
  })
  // 订阅 mutation 执行
  this._subscribers.forEach(sub => sub(mutation, this.state))
  // 省略 非生产环境的警告代码 ...
}
commit 支持多种方式。比如：
store.commit('increment', {
  count: 10
})
// 对象提交方式
store.commit({
  type: 'increment',
  count: 10

（14）dispatch
分发 action
dispatch (_type, _payload) {
  // check object-style dispatch
  // 获取到type和payload参数
  const {
    type,
    payload
  } = unifyObjectStyle(_type, _payload)

  // 声明 action 变量 等于 type和payload参数
  const action = { type, payload }
  // 入口，也就是 _actions 集合
  const entry = this._actions[type]
  // 省略 非生产环境的警告代码 ...
}

（15）replaceState
替换 store 的根状态，仅用状态合并或时光旅行调试。
replaceState (state) {
  this._withCommit(() => {
    this._vm._data.$$state = state
  })
}

（16）watch
响应式地侦听 fn 的返回值，当值改变时调用回调函数。
/**
 * 观测某个值
 * @param {Function} getter 函数
 * @param {Function} cb 回调
 * @param {Object} options 参数对象
 */
watch (getter, cb, options) {
  if (process.env.NODE_ENV !== 'production') {
    assert(typeof getter === 'function', `store.watch only accepts a function.`)
  }
  return this._watcherVM.$watch(() => getter(this.state, this.getters), cb, options)
}

（17）subscribe
订阅 store 的 mutation。
subscribe (fn) {
  return genericSubscribe(fn, this._subscribers)
}
// 收集订阅者
function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn)
  }
  return () => {
    const i = subs.indexOf(fn)
    if (i > -1) {
      subs.splice(i, 1)
    }
  }
}

（18）subscribeAction
订阅 store 的 action。
subscribeAction (fn) {
  const subs = typeof fn === 'function' ? { before: fn } : fn
  return genericSubscribe(subs, this._actionSubscribers)
}

（19）registerModule
注册一个动态模块。
/**
 * 动态注册模块
 * @param {Array|String} path 路径
 * @param {Object} rawModule 原始未加工的模块
 * @param {Object} options 参数选项
 */
registerModule (path, rawModule, options = {}) {
  // 如果 path 是字符串，转成数组
  if (typeof path === 'string') path = [path]
  // 省略 非生产环境 报错代码
  // 手动调用 模块注册的方法
  this._modules.register(path, rawModule)
  // 安装模块
  installModule(this, this.state, path, this._modules.get(path), options.preserveState)
  // reset store to update getters...
  // 设置 resetStoreVM
  resetStoreVM(this, this.state)
}
unregisterModule
卸载一个动态模块。

（20）hotUpdate
热替换新的 action 和 mutation。
// 热加载
hotUpdate (newOptions) {
  // 调用的是 ModuleCollection 的 update 方法，最终调用对应的是每个 Module 的 update
  this._modules.update(newOptions)
  // 重置 Store
  resetStore(this, true)
}

组件绑定的辅助函数
（21）mapState
为组件创建计算属性以返回 Vuex store 中的状态。
export const mapState = normalizeNamespace((namespace, states) => {
  const res = {}
  // 非生产环境 判断参数 states  必须是数组或者是对象
  if (process.env.NODE_ENV !== 'production' && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object')
  }
  normalizeMap(states).forEach(({ key, val }) => {
    res[key] = function mappedState () {
      let state = this.$store.state
      let getters = this.$store.getters
      // 传了参数 namespace
      if (namespace) {
        // 用 namespace 从 store 中找一个模块。
        const module = getModuleByNamespace(this.$store, 'mapState', namespace)
        if (!module) {
          return
        }
        state = module.context.state
        getters = module.context.getters
      }
      // mapState({loginInfo: 'loginInfo'}) mapState(['loginInfo'])
      // mapState({loginInfo: (state, getters)=> {}})
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    }
    // 标记为 vuex 方便在 devtools 显示
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
normalizeNamespace 标准化统一命名空间
normalizeMap 标准化统一 map，最终返回的是数组

（22）mapGetters
为组件创建计算属性以返回 getter 的返回值。
export const mapGetters = normalizeNamespace((namespace, getters) => {
  const res = {}
  // 省略代码：非生产环境 判断参数 getters 必须是数组或者是对象
  normalizeMap(getters).forEach(({ key, val }) => {
    // The namespace has been mutated by normalizeNamespace
    val = namespace + val
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      // 省略代码：匹配不到 getter
      return this.$store.getters[val]
    }
    // mark vuex getter for devtools
    res[key].vuex = true
  })
  return res
})
举例：
computed: {
  ...mapGetters('cart', {
    products: 'cartProducts',
    total: 'cartTotalPrice'
  })
},
最终转换成：
computed: {
  products: this.$store.getters['cart/cartProducts'],
  total: this.$store.getters['cart/cartTotalPrice'],
}

（23）mapActions
创建组件方法分发 action。
export const mapActions = normalizeNamespace((namespace, actions) => {
  const res = {}
  // 省略代码： 非生产环境 判断参数 actions  必须是数组或者是对象
  normalizeMap(actions).forEach(({ key, val }) => {
    res[key] = function mappedAction (...args) {
      // get dispatch function from store
      let dispatch = this.$store.dispatch
      if (namespace) {
        const module = getModuleByNamespace(this.$store, 'mapActions', namespace)
        if (!module) {
          return
        }
        dispatch = module.context.dispatch
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    }
  })
  return res
})

（24）mapMutations
创建组件方法提交 mutation。 mapMutations 和 mapActions 类似，只是 dispatch 换成了 commit。
let commit = this.$store.commit
commit = module.context.commit
return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))





36.vue-router源码解析
1）install 方法做了这麽几件事：
声明一个全局变量 _Vue，用于保存传入的 Vue 然后将其暴露出去，供源码中其他地方使用，这样可以在不将 Vue 打包进源码的前提下随心使用 Vue。
Vue.mixin 全局混入钩子函数（beforeCreate ,destroyed）。
export function initMixin (Vue: GlobalAPI) {
 //mixin 方法，接收一个 Object 类型 mixin 参数
  Vue.mixin = function (mixin: Object) {
    //调用 mergeOptions 将传入的 mixin 对象 合并到 Vue 的 options 上
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
Vue.mixin 中会调用 mergeOptions 这个方法将传入的 mixin 对象通过与 Vue 原有的 options 选项合并成一个新的 option， 然后重新赋给 Vue 的 options 。由于在 Vue 中每个组件的构造函数都会在 extend 阶段合并 Vue.options 到自己的 options 中，这样也就相当于每个组件都定义了 mixin 中定义的选项。所以这也就是通过 Vue.mixin 全局混入的钩子函数会在每一个组件实例初始化的时候被触发调用一次的原因了。

2）class VueRouter
import VueRouter from 'vue-router' 导入的 vue-router 入口文件其实导出的东西就是 VueRouter 这个类。index.js 文件中首先是定义了 vue-router 核心 VueRouter 类，然后是定义了一个注册路由钩子函数的方法和一个创建 href路由跳转路径的方法，下来是将 install 方法挂载给 VueRouter 类的静态 install 方法，最后是一个判断当前运行的浏览器环境的 window 对象上如果挂载了 Vue ,则执行自动安装 vue-router 插件，也就是说只要 import VueRouter from 'vue-router'一执行，上面这些事就会被完成。分析完入口文件被加载时所做的事情后，我们来分析 VueRouter 的实例初始化过程

createMatcher
createMatcher 其实内部就 调用了一个 createRouteMap 方法，这个方法是干嘛的呢，从名字我们就可以猜个差不多，是用来创建路由映射表的一个函数，那辗转又去 createRouteMap 里面吧。
createRouteMap
createRouteMap 方法的功能就是将我们在项目中传入的路由配置（即 new VueRouter({routes,...})中的 routes ）转换成路由映射表,该方法会返回一个对象，对象中包含三个属性，pathList 保存所有的 path； pathMap 保存每个 path 到 RouteRecord 的映射关系；nameMap 保存每个 name 到 RouteRecord 的关系。

3）class History {
    ...
  constructor (router: Router, base: ?string) {
    //将router实例挂载到history实例上
    this.router = router
    //规范化base,如果未配置则给默认值:'/'
    this.base = normalizeBase(base)

    // start with a route object that stands for "nowhere"
    //START: 初始化一个原始current对象（初始化current),项目最开始启动时的current就是这里的START
    /**
     * fullPath: "/"
     * hash: ""
     * matched: []
     * meta: {}
     * name: null
     * params: {}
     * path: "/"
     * query: {}
     */
    this.current = START
   
    this.pending = null
    this.ready = false
    this.readyCbs = []
    this.readyErrorCbs = []
    this.errorCbs = []
  }
}
History 基类的构造函数先将 router (new VueRouter) 实例挂载到 history 实例上，然后对 base 进行规范化（如果未配置则给默认值:'/'），下来初始化一个原始 current 对象（初始化current),这里的 current 初始值 是通过 START 产生的，START 其实是 createRoute 方法用 path = '/'创建的一个 route 对象，也被称为原始 route 对象，这样 current 就拿到了项目初始化（项目启动）时最原始的 route 路由对象，最后初始化了一些内置属性。

4）transitionTo

5) RouteLink
RouteLink 组件首先是可以接收多个 props 选项，其中 to 是必传选型，其余都是可选，默认 tag 标签为 a ，默认触发跳转的事件为 click。该组件渲染也依赖于 render 函数，render 函数中首先拿到 router （$router）实例 和 当前激活态 route 对象（$route）,然后调用 router.resolve() 进行路由解析后取出 location、route、href。（location 表示规范化后的目标 location, route表示通过 match 匹配然后调用 createRoute 生成的最终目标 route，href 表示通过调用 createHref 计算出来的最终要跳转的 href ）
<router-view>是一个渲染函数，它的渲染是用了Vue的 render 函数，它接收两个参数，第一个是Vue实例，第二个是一个context，通过对象解析的方式可以拿到 props、children、parent、data，供创建 <router-view> 使用。
const component = cache[name] = matched.components[name]

6）导航守卫
导航 表示路由正在发生变化，vue-router 提供的导航守卫主要用来通过跳转或者取消的方式守卫导航。导航守卫分为三种：全局守卫、单个路由守卫和组件内的守卫。
全局守卫：
全局前置守卫 beforeEach (to, from, next)
全局解析守卫 beforeResolve (to, from, next)
全局后置钩子 afterEach (to, from)
单个路由守卫：
路由前置守卫 beforeEnter (to, from, next)
组件内的守卫：
渲染组件的对应路由被confirm前 beforeRouterEnter (to, from, next) next可以是函数，因为该守卫不能获取组件实例，新组件还没被创建
路由改变，该组件被复用时调用 (to, from, next)
导航离开该组件对应路由时调用 beforeRouteLeave

router.beforeEach((to, from, next) => {
  // ...
})
每个守卫方法接收三个参数：
to: Route: 即将要进入的目标 路由对象
from: Route: 当前导航正要离开的路由
next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。
next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。
next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。





37.插件编写
import ToastComponent from './Toast.vue'
const Toast = {}
Toast.install = function (Vue) {
  const ToastPlugin = Vue.extend(ToastComponent)
  const instance = new ToastPlugin()
  // 将这个实例挂载在我创建的div上
  // 并将此div加入全局挂载点内部
  instance.$mount((document.createElement('div')))
  document.body.appendChild(instance.$el)
  // 通过Vue的原型注册一个方法
  // 让所有实例共享这个方法
  Vue.prototype.$toast = (msg, duration = 2000) => {
    instance.message = msg
    instance.show = true
    setTimeout(() => {
      instance.show = false
    }, duration)
  }
}
export default Toast
Toast.vue:
<template>
		<transition name="fade">
				<div class="toast" v-show="show">
						{{message}}
				</div>
		</transition>
</template>
<script>
export default {
  data () {
    return {
      message: '',
      show: false
    }
  }
}
</script>
<style lang="scss" scoped>
		.toast {
				......
		}
		.fade-enter-active, .fade-leave-active {
				transition: 0.5s ease-out;
		}
		.fade-enter {
				opacity: 0;
				transform: scale(1.2);
		}
		.fade-leave-to {
				opacity: 0;
				transform: scale(0.8);
		}
</style>
使用：
import Toast from './plugins/Toast'
Vue.use(Toast)




38.vue.extend()
vue.extend()方法其实是vue的一个构造器,目的是创建一个Vue的子类.
所以他不能直接在new Vue中这样使用,最终还是要通过Vue.components注册才可以使用的。
var apple = Vue.extend({
    ....
 })
Vue.component('apple',apple) 
var Profile = Vue.extend({
  template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
  data: function () {
    return {
      firstName: 'Walter',
      lastName: 'White',
      alias: 'Heisenberg'
    }
  }
})
// 创建 Profile 实例，并挂载到一个元素上。
new Profile().$mount('#mount-point')
传入属性需要使用propsData.
new Profile({
    propsData: {
	    firstName: '123'
	}
})



39.vue.set()
由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，
所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的.
可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。
Vue.set( target, key, value )
target：要更改的数据源(可以是对象或者数组)
key：要更改的具体数据
value ：重新赋的值

您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：
例：this.$set(this.someObject,'b',2)
data:{
		items:['a', 'b', 'c']
	},
methods:{
		btn(){
			this.$set(this.items, 1, 'e')
			console.log(this.items)
		}
	}




40.babel.config.js 如何配置
主要两个东西：
presets //预设
plugins // 插件，需要下载然后再在这配置
详细参考文档：
https://www.babeljs.cn/docs/7.2.0/configuration
https://www.babeljs.cn/docs/7.2.0/presets
https://babel.docschina.org/docs/en/plugins // 汇总plugin




41.history
base: process.env.NODE_ENV === 'production' ? '/msb/webMsb' : process.env.BASE_URL,
nginx: html下创建/msb/webMsb
		location  ^~/msb/webMsb {
                index index.html;
                try_files $uri $uri/ /msb/webMsb/index.html @router;
        }



42.自定义指令方法
import Vue from 'vue'

const auth = Vue.directive('auth', {
  bind (el, binding, vnode) {
    console.log(el)
    console.log(binding)
    console.log(vnode.context)
    console.log(vnode.context.$route)
    // el.parentNode.removeChild(el);
  }
})

export default auth
main.js: 
import './directive/auth'
钩子函数介绍
指令定义函数提供了几个钩子函数（可选）
bind：只调用一次，指令第一次绑定到元素时调用。
inserted：被绑定元素插入父节点时调用。
update：所在组件的VNode更新时调用，但是可能发生在其子 VNode 更新之前。
componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。
unbind：只调用一次，指令与元素解绑时调用。






43.vite
1)创建项目
npm install -g create-vite-app
npm init vite-app viteVue3 // npm init vite-app <project-name>
cd viteVue3
npm install
npm run dev

由于我们用的是 VUE3.0,所以我们VUE-ROUTER也要对应版本为 4.X.
npm install vue-router@next -S
npm install vuex@next -S

2）集成ts:
yarn add typescript -D
npx tsc --init
把main.js转为main.ts
把.vue文件里的scripts转为ts
index.html里src="/src/main.js"改为src="/src/main.ts"
新建shim-vue.d.ts：
declare module "*.vue" {
    import { Component } from "vue";
    const component: Component;
    export default components;
}
/**
 * shims-vue.d.ts的作用
 * 为了 typescript 做的适配定义文件，因为.vue 文件不是一个常规的文件类型，ts 是不能理解 vue 文件是干嘛的，
 * 加这一段是是告诉 ts，vue 文件是这种类型的。
 * 可以把这一段删除，会发现 import 的所有 vue 类型的文件都会报错。
 */
 
就是说，虽然 TypeScript 本身不支持导入非 JavaScript 内容，但是为了支持其他工具接下来的工作，所以做了这么个语法支持。
*.vue 这个大概是 webpack 的 vue-loader 支持的

3）安装router
npm install vue-router@next -S (npm install vue-router@4.0 会出现箭头让你选)
在src下创建router目录,再创建inex.ts文件：
import {createRouter, createWebHashHistory} from 'vue-router'
export default createRouter({
    history: createWebHashHistory(),
    routes: []
})
在main.ts：
	app.use(router)

4）安装vuex:
npm install vuex@next -S
创建store文件夹，再新建index.ts
	import { createStore } from 'vuex'

	export default createStore({
		state: {
			userName: '王大锤'
		}
	})
在main.ts：
import router from './router/index'
import vuex from './store/index'
const app = createApp(App)
app.use(router)
app.use(vuex)
app.mount('#app')

5）vite.config.js
vite项目中使用的不是vue.config.js,而是vite.config.js
import type { UserConfig } from 'vite'
const  viteConfig:UserConfig = {
    port: 3555,
    proxy: {
        '/api': {
            target: 'http://192.168.11.206',
            changeOrigin: true,
            rewrite: path => path.replace('/^\/api', '')
        }
    }
}
export default viteConfig
6）axios
npm install axios

7）vant3
npm install vant@next -S









44.vue3新特点
新开发工具vite
	使用rollup打包
组合式api	
	同时支持options api和composition API
	composition-api 把复杂组件的逻辑抽地更紧凑，而且可以将公共逻辑进行抽取
新的响应式函数proxy, let proxy = new Proxy({name: "123"}, {get(){}, set(){}})
新的全家桶
对typescript全新支持
重写了 Vdom ，突破了 Vdom 的性能瓶颈
支持了 tree-shaking
1）入口函数setup
	创建组件前使用
	它将接受两个参数：
		props
		context
		props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性
		context 是一个普通的 JavaScript 对象{ attrs, slots, emit }
2）watchEffect
const stop = watchEffect(() => {
  /* ... */
})
// later 用于停止这个监听的函数
stop()
3）setup()
使用Composition API 的入口
在beforeCreate之前调用
在setup中没有this
返回对象中的属性刻在模板中使
4）ref和reactive
ref只可以监听简单数据，reactive可以监听所有数据
ref通过.value的形式来修改
ref 和 reactive 本质我们可以简单的理解为ref是对reactive的二次包装, ref定义的数据访问的时候要多一个.value
使用ref定义基本数据类型,ref也可以定义数组和对象。
5）readonly
传入ref或reactive对象,并返回一个原始对象的只读代理,对象内部任何嵌套的属性也都是只读的。
传入普通对象等也返回只读代理
传入普通数值或字符串不能变成只读
	import {readonly } from 'vue'
	setup()
	{
		const xx=readonly(参数);
	}
5）toRefs函数
toRefs()函数可以将reactive()创建出来的响应式对象，转换为普通对象，只不过这个对象上的每个属性节点，都是ref()类型的响应式数据







45.jest单元测试
1）配置可以在package.json中（也可以创建jest.config.js）：
"jest": {
    "moduleFileExtensions": [
      "js",
      "jsx",
      "json",
      "vue"
    ],
    "transform": {
      "^.+\\.vue$": "vue-jest",
      ".+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$": "jest-transform-stub",
      "^.+\\.jsx?$": "babel-jest"
    },
    "moduleNameMapper": {
      "^@/(.*)$": "<rootDir>/src/$1"
    },
    "snapshotSerializers": [
      "jest-serializer-vue"
    ],
    "testPathIgnorePatterns": [
      "<rootDir>/test/e2e"
    ],
	"testMatch": [
      "**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)"  // 运行全部测试文件
    ],
    // "testRegex": "storageTool.spec.js", // 只运行单个测试文件
    "testURL": "http://localhost/",
    "collectCoverage": true,
    "coverageDirectory": "<rootDir>/tests/unit/coverage",
    // "collectCoverageFrom": ["**/src/utils/**"] // 要测试的文件
	"collectCoverageFrom": ["**/src/**.{js,vue}", "!**/node_modules/**", "!**src/main.js**", "!**src/router.js**"]
  }

2）collectCoverage覆盖率报告：
// branches 分支覆盖率
// functions 函数执行的覆盖率
// lines 代码函数覆盖率
// statements 声明的覆盖率

3）expect常用匹配方法:
toBe 使用 Object.is 判断是否严格相等。
toEqual 递归检查对象或数组的每个字段。
toBeNull 只匹配 null。
toBeUndefined 只匹配 undefined。
toBeDefined 只匹配非 undefined。
toBeTruthy 只匹配真。
toBeFalsy 只匹配假。
toBeGreaterThan 实际值大于期望。
toBeGreaterThanOrEqual 实际值大于或等于期望值
toBeLessThan 实际值小于期望值。
toBeLessThanOrEqual 实际值小于或等于期望值。
toBeCloseTo 比较浮点数的值，避免误差。
toMatch 正则匹配。
toContain 判断数组中是否包含指定项。
.toHaveProperty(keyPath, value) 判断对象中是否包含指定属性。
toThrow 判断是否抛出指定的异常。
toBeInstanceOf 判断对象是否是某个类的实例，底层使用 instanceof。
toMatchObject

4）处理第三方库和组件
import Vant from 'vant'
const localVue = createLocalVue()
localVue.use(Vant)
wrapper = shallowMount(HeadComponent, {
      localVue,
      stubs: ['app-button'] // 存根，忽略此子组件
})
什么是存根？
在自上而下的集成测试中使用存根，以便模拟尚未集成的较低级别模块的行为。（即还在开发中的模块，不能集成。因此，Stubs用于测试模块。）
Stub是作为被调用模块的临时替换的模块，并提供与实际产品相同的输出。

5）测试props
const itemProps = {
      activityName: '2021.Q1',
	  activityPictureUrl: 'http://test.sccddw.com/bg'      
    }
    wrapper.setProps({
      item: itemProps
    })
 // eslint-disable-next-line
    expect(wrapper.props().item.activityName).toBe(itemProps.activityName)
	// eslint-disable-next-line
    expect(wrapper.find('.img').element.style.backgroundImage).toBe('url(http://test.sccddw.com/bg)')
	
6)测试click
methods: {
    onClick () {
      this.$emit('click', 'i am params') // 此处的参数'i am params'纯为测试准备，并未真正使用
    }
  },
 // eslint-disable-next-line
  it('copy test', () => {
    const imgWrapper = wrapper.find('img')
    // eslint-disable-next-line
    const mockFn = jest.fn()
    imgWrapper.trigger('click') //注意: trigger是异步的,可能需要await

    wrapper.setMethods({
      onClick: mockFn
    })
    // 断言函数被触发且只触发一次
    // eslint-disable-next-line
    expect(mockFn).toBeCalled()
    // eslint-disable-next-line
    expect(mockFn).toHaveBeenCalledTimes(1)
  })
	
// 测试内容：$emit
  // 函数被触发后，emit的函数也会被触发
  it('when onClick is called $emit is called', () => {
    const wrapper = shallowMount(AppButton)
    // 测试$emmit函数被正确触发
    // mock函数替代点击按钮后$emit的函数，此处函数名相同，依然为click
    const mockFn1 = jest.fn()
    wrapper.vm.$on('click', mockFn1)
    // 测试mock函数是否被触发，触发的次数,以及参数
    wrapper.vm.onClick()
    expect(mockFn1).toBeCalled()
    expect(mockFn1).toHaveBeenCalledTimes(1)
    expect(mockFn1).toHaveBeenCalledWith('i am params')
    // 第二次点击button，依然测试mock函数是否被触发，触发的次数
    wrapper.vm.onClick()
    expect(mockFn1).toBeCalled()
    expect(mockFn1).toHaveBeenCalledTimes(2)
    expect(mockFn1).toHaveBeenCalledWith('i am params')

    wrapper.destroy()
  })	
	
7)测试slot
const _wrapper = shallowMount(HeadComponent, {
      localVue,
      slots: {
        content: '<span>测试slot</span>'
      }
    })
    const slotContent = _wrapper.find('.content-slot')
    console.log('slotContent', slotContent.html())
    // eslint-disable-next-line
    expect(slotContent.contains('span')).toBe(true)
    const slotContentSpan = _wrapper.find('.content-slot span')
    // eslint-disable-next-line
    expect(slotContentSpan.text()).toBe('测试slot')
	
8) 测试v-show
	// 测试内容：v-show 测试，v-if v-bind的测试思路基本相同，
  // 设置变量的值，断言对应的DOM结构显示与否
  it('v-show test', () => {
    // true时显示的div
    const truediv = wrapper.find('.text.format')
    // false时显示的div
    const falsediv = wrapper.find('.text.noformat')
    // toggleShow默认值为true
    expect(truediv.isVisible()).toBe(true)
    expect(falsediv.isVisible()).toBe(false)
    // 设置为false
    wrapper.vm.toggleShow = false
    expect(truediv.isVisible()).toBe(false)
    expect(falsediv.isVisible()).toBe(true)
  })
  
9）测试filter
filters: {
    formatText: function (value) {
      // console.log(value)
      if (!value) return ''
      if (value.length > 7) {
        let frontVal = value.slice(0, 2)
        let endVal = value.slice(value.length - 2, value.length)
        return frontVal + '...' + endVal
      } else {
        return value
      }
    }
  }
import FilterTest from '@/components/FilterAddWatchTest.vue'
  // 测试内容：filter----filter不能通过wrapper或者vm获取，只能通过组件获取
  // filter需要测试函数的所有可能性
  it('filter test', () => {
    // console.log(FilterTest.filters)
    expect(FilterTest.filters.formatText('12345678')).toBe('12...78')
    expect(FilterTest.filters.formatText('12345')).toBe('12345')
    expect(FilterTest.filters.formatText()).toBe('')
  })
  
10)测试watch
watch: {
    toggleShow(newValue, oldValue){
      console.log(newValue)      
    }
  }
  it('watch test', () => {
    // mock掉console.log
    const spy = jest.spyOn(console, 'log') // 把console.log替换成一个mock function
    // 手动将变量的值设置为false,默认值是true
    wrapper.vm.toggleShow = '自定义'
    // 断言函数是否执行, 通过console.log是否执行判断toggleShow是否watch成功
    expect(spy).toBeCalled()
    expect(spy).toHaveBeenCalledTimes(1)
    expect(spy).toHaveBeenCalledWith('自定义')
    // 清除掉mock
    spy.mockClear()
  })
	
11）测试computed
computed: {
    cssClasses () {
      let classes = ['app-button']
      classes.push('app-button--' + this.size)
      if (this.type && !this.disabled) {
        classes.push('app-button--' + this.type)
      }
      if (this.disabled) {
        classes.push('app-button--disabled')
      }
      return classes.join(' ')
    }
  }
// 测试内容：computed(要注意计算属性不是函数，是变量，测试时很容易看着组件内写法按照函数测试)
  // 改变props的type，size，disable值时，cssClasses的值也会跟着改变
  it('computed test', () => {
    const wrapper = shallowMount(AppButton)
    // 设置props 断言computed计算属性（注意props有default值）
    wrapper.setProps({ type: 'danger' })
    expect(wrapper.vm.cssClasses).toBe('app-button app-button--md app-button--danger')
    wrapper.setProps({ size: 'lg' })
    expect(wrapper.vm.cssClasses).toBe('app-button app-button--lg app-button--danger')
    wrapper.setProps({ disabled: true })
    expect(wrapper.vm.cssClasses).toBe('app-button app-button--lg app-button--disabled')

    wrapper.destroy()
  })

12) 测试route
const mockPush = jest.fn()
const $router = {
  push: mockPush
  // ... 其他属性
}
const $route = {
  path: '/ActivityScore',
  name: 'ActivityScore',
  query: {
    id: 121
  }
}
wrapper = shallowMount(ActivityScore, {         
      stubs:  ['router-link', 'router-view'],
      mocks: {
        $route,
        $router
      }
    })
注意：不要在其他文件使用import router from '../router'，
	 会造成could not overwrite property $route的错误，所以测试时先不要用

13)测试methods
(1) 普通方法
wrapper.vm.onClick()
expect() // 在判断函数的逻辑，如更改数据呀、执行方法呀、返回值呀
(2) 异步方法
mock整个模块：
jest.mock('@/http/http', () => ({
  get () {
    return Promise.resolve({
      data: {}
    })
  },
  post () {
    return Promise.resolve({
      data: {}
    })
  }
}))
mock api:
// eslint-disable-next-line
jest.mock('@/api/index', () => ({
  findActivityById: jest.fn().mockResolvedValue({
    data: {
      activityName: '2021.Q1'
    }
  }),
  findActivityMainPageById: jest.fn().mockResolvedValue({
    data: []
  })
}))
当想修改返回值时，使用mockImplementation：
import { findActivityById } from '@/api/index'
findActivityById.mockImplementation(() => ({
      data: {
        activityName: '2021.Q1.qqqq'
      }
    }))
如何mock methods:
const  findActivityById = jest.spyOn(_wrapper.vm, 'findActivityById')
异步方法需要await等待其完成：
await _wrapper.vm.findActivityById()


14) 测试vuex
import { shallowMount, createLocalVue } from '@vue/test-utils'
import VuexTest from '@/components/VuexTest.vue'
import Vuex from 'vuex'
const localVue = createLocalVue()
localVue.use(Vuex)
let wrapper
  let actions
  let state
  let getters
  let mutations
  let store
  beforeEach(() => {
  // 伪造actions state getters mutations
    actions = {
      increment: jest.fn(),
      decrement: jest.fn()
    }
    console.log('actions', actions)
    mutations = {
      increment: jest.fn(),
      decrement: jest.fn()
    }
    state = {
      count: 0
    }
    getters = {
      evenOrOdd: () => 'gettersVal' // 伪造的越简单越好
    }
    // 伪造store
    store = new Vuex.Store({
      state,
      actions,
      mutations,
      getters
    })
    // 挂载store
    wrapper = shallowMount(VuexTest, {
      localVue,
      store,
      stubs: ['app-button']
    })
  })

  afterEach(() => {
    wrapper.destroy()
  })
// 测试内容：state
  // 只需测试伪造的state值是否存在于dom中
  it('getters test', () => {
    const text = wrapper.find('.text')
    expect(text.text()).toContain(state.count)
  })
  // 测试内容：actions-通过点击按钮直接调用
  // 点击按钮测试伪造的函数是否被调用
  it('actions test', () => {
    const buttonAdd = wrapper.find('.add')
    const buttonMinus = wrapper.find('.minus')
    buttonAdd.vm.$emit('click')
    expect(actions.increment).toHaveBeenCalled()
    expect(actions.increment).toHaveBeenCalledTimes(1)
  })
// 测试内容：mutations
  // 调用函数测试伪造的函数是否被调用
  it('mutations test', () => {
    wrapper.vm.mutationsDecrement()
    expect(mutations.decrement).toHaveBeenCalled()
    expect(mutations.decrement).toHaveBeenCalledTimes(1)
  })
  // 测试内容：getters
  // 只需测试伪造的getters值是否存在于dom中
  it('getters test', () => {
    const text = wrapper.find('.text')
    expect(text.text()).toContain(getters.evenOrOdd())
  })
  
15)快照测试 snapshot
安装一个自定义的序列化工具
 npm install --save-dev jest-serializer-vue
 package.json 中配置它：
 "jest": {
    // ...
    // 快照的序列化工具
    "snapshotSerializers": ["jest-serializer-vue"]
  }
  测试代码：
  // eslint-disable-next-line
  it('snapshot test', () => {
    const _wrapper = shallowMount(ActivityScore, {
      localVue,
      // router,
      stubs: ['van-icon', 'van-radio-group'],
      mocks: {
        $route,
        $router
      }
    })
	// 需要2次nextTick，第一次shallowMount，第二次api异步更新
    // eslint-disable-next-line
    _wrapper.vm.$nextTick(() => {
      _wrapper.vm.$nextTick(() => {
      expect(_wrapper.html()).toMatchSnapshot()
      _wrapper.destroy()
      })
    })
  })
  toMatchSnapshot()快照匹配的执行流程：
		1、第一次运行generateConfig函数时，没有快照，调用toMatchSnapshot()匹配器时，会自动帮我们生成一个快照。
		把generateConfig函数返回的内容存到快照里边去。
		2、当我们修改业务文件进行保存后，toMatchSnapshot()又会生成一次快照，跟上次生成的快照相对比，如果一致，则测试通过，
		   如果不一致，则测试不通过，证明有代码改动。
		3、快照文件为：_ _ snapshots_ _/demo.test.js.snap (如下)
如果出现Your test suite must contain at least one test错误是因为testRegex的原因

单元测试内容：
工具函数：
	不同输入，是否有正确输出；固定输入下输出是否固定
组件：
	默认值是否正确
	当用户选择日期范围，data是否会做相应改变



























