1.tomcat下载：
	https://tomcat.apache.org/download-80.cgi
	下载zip文件

2.配置
	conf/tomcat-users.xml
	添加：
	<user username="admin" password="admin" roles="manager-gui,admin-gui"/>
	conf/web.xml
	添加：
	<init-param>
            <param-name>compilerSource</param-name>
            <param-value>1.8</param-value>
        </init-param>
        <init-param>
            <param-name>compilerTargetVM</param-name>
            <param-value>1.8</param-value>
        </init-param>
	conf/server.xml可以修改接口

3.运行
	./startup.sh
	如果出现startup.sh: command not found
        需要更改startup.sh权限
	sudo chmod 755 *.sh //需要在tomcat-xxx/bin/目录下执行
	执行成功访问http://localhost:8080/
	./shutdown.sh关闭tomcat

4.创建Maven
	groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为org、com、cn等等许多。如：top.hellozwj
	artifactId设置为项目的名称;
	使用阿里maven：
	修改pom.xml:
		<repositories><!-- 代码库 -->
        		<repository>
          			<id>maven-ali</id>
            			<url>http://maven.aliyun.com/nexus/content/groups/public//</url>
            			<releases>
                			enabled>true</enabled>
            			</releases>
            			<snapshots>
                			<enabled>true</enabled>
                			<updatePolicy>always</updatePolicy>
                			<checksumPolicy>fail</checksumPolicy>
            			</snapshots>
        		</repository>
    		</repositories>
	如果想修改settings文件的话：settings.xml的默认路径就：个人目录/.m2/settings.xml
		Mac下在～/.m2/下,如果没有就自己创建
			内容：<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
      				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      				xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                          	https://maven.apache.org/xsd/settings-1.0.0.xsd">
  				<localRepository/>
  				<interactiveMode/>
  				<usePluginRegistry/>
  				<offline/>
  				<pluginGroups/>
  				<servers/>
  				<mirrors/>
  				<proxies/>
  				<profiles/>
  				<activeProfiles/>
			</settings>
			
5.下载离线maven
http://maven.apache.org/download.cgi
Mac 下载-bin.tar.gz解压到zwj/applictions
在使用idea创建maven时，更改默认的maven,选择解压的目录就到apache-maven-3.5.4
同时settings也要改为apache-maven-3.5.4/conf/settings.xml
<mirrors>中添加
	<mirror>
        	<id>nexus-aliyun</id>
        	<mirrorOf>*</mirrorOf>
        	<name>Nexus aliyun</name>
        	<url>http://maven.aliyun.com/nexus/content/groups/public</url>
    	</mirror>


6.IDEA设置tomcat
	run->Edit Configurations
	点击：+,点击：tomcat server,点击：local
	然后配置tomcat，选择解压的tomcat目录
	如果出现错误：no artifacts configured：
	打开file->Project Structure,选择Aritfacts选项， 选择Web Application:Exploded,修改命名name,在右边avilable elements下选中要添加的项目，点击+，选择directory content,选择项目的目录.再次进入Edit Configration->Deployment，点击+号，即可看到Artifact选项了.(注意：Aritfact一定要是：xxx:war exploded)
	war模式：将WEB工程以包的形式上传到服务器 ；
	war exploded模式：直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署，一般在开发的时候也是用这种方式。
	就可以运行项目了，但什么都没有浏览器会显示404

7.创建webapp
选择Maven项目时，勾选create from archetype,并选中org.apache.maven.archetypes:maven-archetype-webapp.
然后创建完项目后会加载很多依赖，会很慢，加载完后才会出现所有目录结构，不然只有pom.xml。
最后下载离线的Maven，在创建项目时更改为自己下载的maven解压后的目录，settings.xml也要更改为自己的settings.xml在maven目录的conf目录里。

8.创建的项目main下没有java目录
解决：   选择File->Project Structure
	选择Modules选项卡下面的Sources项，在main文件夹上右键，选择New Folder...并点击OK
	输入要创建的文件夹名称java，并点击OK继续
	在创建好的java文件夹上右键选择Sources项将该文件夹标记为源文件夹
	我们发现java文件夹已经由黄色变成了蓝色，我们点击OK按钮表示设置完成（蓝色就对了）
解决2:在main文件夹上右键,直接创建目录，即可。

9.Servlet should have a mapping
请添加<servlet-mapping>
    	<servlet-name>HelloWorld</servlet-name>
    	<url-pattern>/hello</url-pattern>
     </servlet-mapping>


10.创建断点
<servlet>下添加
<load-on-startup>1</load-on-startup>

11.@WebServlet(
        name = "hello",
        urlPatterns = {"/hello","/greeting"},
        loadOnStartup = 1
)可以代替web.xml的servlet的配置


12.javax.inject.jar：依赖注入非常方便的jar包.
用过Spring框架的我们都知道，每当生成依赖注入的时候，我们都必须生成相应类的set方法，而且要在set方法上面写上@Autowired，才能实现依赖注入.


13.scope=compile的情况（默认scope),也就是说这个项目在编译，测试，运行阶段都需要这个artifact对应的jar包在classpath中。
scope=provided的情况，则可以认为这个provided是目标容器已经provide这个artifact。换句话说，它只影响到编译，测试阶段。在编译测试阶段，我们需要这个artifact对应的jar包在classpath中，而在运行阶段，假定目标的容器（比如我们这里的liferay容器）已经提供了这个jar包，所以无需我们这个artifact对应的jar包了。
即scope=provided，打包不会打包进去。


14.Artifact 是maven中的一个概念，表示某个module要如何打包。


15scope的分类
compile
默认就是compile，什么都不配置也就是意味着compile。compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。
test
scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。
runntime
runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。
provided
provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。
system
从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用。


16.RSS 简单信息聚合

17.SOAP(simple object access protocol)简单对象访问协议

18.ORM对象关系映射
面向对象编程语言

19.应用服务器有专门用于管理连接池的内建系统，可以改善应用程序中数据库连接的性能。对应管理这些连接的应用服务器，必须在应用服务器类加载器中而不是web应用类加载器中加载JDBC驱动。
在mysql官网下载mysql JDBC,拿到JAR文件,把它放到tomcat\lib下。修改tomcat\conf\context.xml
在<Context>里添加
<Resource
            name="jdbc/GZXS"
            type="javax.sql.DataSource"
            maxActive="100"
            maxIdle="30"
            maxWait="5000"
            username="root"
            password="123456"
            driverClassName="com.mysql.jdbc.Driver"
            url="jdbc:mysql://localhost:3306/GZXS?autoReconnect=true&amp;useSSl=false"
    />
//maxIdle连接池中最少空闲30个连接，maxWait连接池连接用完时新请求等待时间，name为Resource的名字,&amp;是&的转义符直接使用&会报错。
mysql-connector-java-bin.jar与mysql-connector-java.jar
使用上是没区别的一样的,都可以用,带-bin的文件里在编译的的时候里面多了几个编译用的校验文件而已.
数据源在tomcat /conf/content/xml与/conf/server.xml的区别
server.xml不可动态重新加载资源，要修改这个文件，就要重启才能重新加载。context.xml文件，tomcat一旦文件修改(时间戳改变)，就会重新加载这个文件，不需要重启服务器。

20.ubuntu 安装tomcat9
下载：apache-tomcat-9.0.11.tar.gz
解压到/usr/local
修改tomcat/bin下的startup.sh文件，在最后添加
export JAVA_HOME=/usr/local/java
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH

启动tomcat
  ./bin/startup.sh
  curl localhost:8080
关闭tomcat
  ./bin/shuntdown.sh

21.SpringMVC 中 url-patter 与 @RequestMapping 的对应问题
利用 SpringMVC 响应前端发起的请求时，其完整 url 会按照 DispatcherServlet 指定的 url 格式进行匹配、修剪，去掉<url-pattern>指定的上下文部分，剩余部分 url'，再由注解 @RequestMapping 转到 Controller 特定的方法上，执行具体的处理。
前端请求的完整 url：
	http://localhost:8088/aaa/bbb/ccc?myParam=myValue
servlet 指定的 url 格式：
	<url-pattern>/aaa/*</url-pattern> <!-- *一定要加不然访问不了 -->
则 @RequestMapping 的正确配置为：
	@RequestMapping(value="/bbb/ccc")
	public String demoMethodSignature(String myParam) 
	

22.Spring项目
Controller层：负责具体业务模块流程的控制，即调用Service层的接口来控制业务流程。负责url映射（action）。
Dao层：负责数据持久化，与数据库进行联络的任务都封装在其中，Dao层的数据源以及相关的数据库连接参数都在Spring配置文件中进行配置。
Entity层：java对象，与数据库表一一对应，是其对应的实现类。即一个Entity就是对应表中的一条记录。
Service层：建立在DAO层之上，Controller层之下。调用Dao层的接口，为Controller层提供接口。负责业务模块的逻辑应用设计，首先设计接口，再设计其实现的类。
View层：表示层，负责前端jsp页面表示。

23.JDBC连接数据库java.sql.Connection
<dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
</dependency>
import java.sql.*;
//声明Connection对象
         Connection con;
         //驱动程序名
        String driver = "com.mysql.jdbc.Driver";
         //URL指向要访问的数据库名mydata
         String url = "jdbc:mysql://localhost:3306/sqltestdb";
         //MySQL配置时的用户名
         String user = "root";
        //MySQL配置时的密码
         String password = "123456";
             //加载驱动程序
             Class.forName(driver);
             //1.getConnection()方法，连接MySQL数据库！！
             con = DriverManager.getConnection(url,user,password);
	     Statement stat = conn.createStatement()创建一个Statement对象来将SQL语句发送到数据库
	    //要执行的SQL语句
             String sql = "select count(1) from VIEW_JLZDH_OB_DL_DAY";
	    //ResultSet类，用来存放获取的结果集！！
            ResultSet rs = statement.executeQuery(sql);
	    while (rs.next()){
                //输出结果
                System.out.println(rs.getString("count(1)"));
            }

24.mac IDEA try catch自动添加，option+command+t

25.preparedStatement与Statement
preparedStatement是预编译的，对批处理可以大大提高效率，Statement只执行一次性存取。preparedStatement用于执行带参数的预编译SQL, Statement执行不带参数的简单SQL。执行的对象较多时，preparedStatement会降低运行时间。企业更喜欢preparedStatement，因为它更安全，传递给preparedStatement的对象参数可以被强制进行类型转换。Statement每次执行一个SQL，都会对它进行解析和编译。preparedStatement和Statement都需要调用close函数关闭，不应等待对象自动关闭。

26.java:comp/env/
这是J2EE环境的定义，代表了当前J2EE应用的环境，使用这样的方式，必须设置当前应用环境到资源名的映射。

27.JDBC-DataSource(数据库连接池)
JDBC的数据库连接池使用javax.sql.DataSource来表示，它只是一个接口，该接口由应用服务器实现，或开源组织（DBCP,C3P0）.
DBCP:
需要两个依赖：commons-dbcp.jar，commons-pool.jar
Tomcat的连接池正是采用这个连接池实现的，可以和应用服务器整合使用，也可以由程序单独使用。
C3P0:
C3p0性能更胜一筹，hibernate推荐使用该连接池，c3p0连接池不仅可以自动清理不使用的connection，还可以自动清理statement和resultset.


28.idea创建springboot项目
Maven的Snapshot版本与Release版本
1. Snapshot版本代表不稳定、尚处于开发中的版本
2. Release版本则代表稳定的版本
1）选择File –> New –> Project –>Spring Initialer –> 点击Next 
2）自己修改 Group 和 Artifact 字段名 –>点击next 
3）选择web，勾选web, spring boot可以选择spring boot版本
4）点击finish 
5)等待编译完成(这个貌似翻墙会好点,要不然下载依赖特别慢。。。)

29.application.properties
原来spring boot2.0之后，server.context-path上下文的配置改为了server.servlet.context-path


30.idea spring打包为war包
<packaging>jar</packaging>改为
<packaging>war</packaging>
主程序文件修改如下：
@SpringBootApplication
public class XsApplication extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(
            SpringApplicationBuilder application) {
        return application.sources(XsApplication.class);
    }


    public static void main(String[] args) {
        SpringApplication.run(XsApplication.class, args);
    }
}
修改pom.xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <!-- 移除嵌入式tomcat插件 -->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
</dependency>
或
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <scope>provided</scope>
</dependency>
在project settings点击artifacts:
点击+，选择web application archive,勾选include in project build(或Build on make,视idea版本而定，勾选了才会产生war包不然就是个目录)，在下面点击+号选择Directory Content，选择你的项目目录整个目录哟，点击ok.
点击build->Build Artifacts，选xs.war(war与war exploded的区别见6，如果没有先build一次idea会自动生成war和war exploded)，如果是第二次build就选择rebuild。

server.contextPath=/prefix/其中prefix为前缀名。这个前缀会在war包中失效，取而代之的是war包名称。

问题：Error:(12, 8) java: 无法访问javax.servlet.ServletException 找不到javax.servlet.ServletException的类文件
Pom.xml添加
<dependency>
    <groupId>javax</groupId>
    <artifactId>javaee-api</artifactId>
    <version>7.0</version>
</dependency>


31.如果使用spring-boot的服务器
在Edit Configurations时选择Spring-boot,Main class填写
com.cddw.com.xs.XsApplication


32. fastjson将容器转为字符串
<dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.50</version>
</dependency>

33.创建普通maven工程
idea:
点击Create New Project ->然后选择Maven->新建普通的Java工程，因此选择-quickstart,如果是新建Java web工程就选择-webapp
->填写GroupID与ArtifactId (GroupID :com.test一般填域名, ArtifactId :一般为项目名)
-> 点击下一步 -> 填写工程名和保存路径 -> 点击下一步，工程建好后，会自动下载Maven相关的包
创建运行环境：
点击Run->Edit Configurations ，接着点击 + ，在新出来的界面，点击Application


33.spring boot jdbc连接池
<dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
如果添加以上依赖那么已默认启用了数据库链接池
常用连接池：dbcp,dbcp2，druid,c3p0,hikari
hikari是性能最强的连接池，优化力度大。
#指定数据源
spring.datasource.type=com.zaxxer.hikari.HikariDataSource
#指定连接维护的最小空闲连接数，当使用HikariCP时指定.
spring.datasource.hikari.minimum-idle=10
#指定连接池最大的连接数，包括使用中的和空闲的连接.
spring.datasource.hikari.maximum-pool-size=30
#指定连接池等待连接返回的最大等待时间，毫秒单位.
spring.datasource.hikari.max-lifetime=500000


34.springboot项目结构
在com.xxx.xxx下
entity
    usr类
service
    使用dao的数据做逻辑操作
dao
    usrDao为接口
    usrDaoImpl实现其接口
controller
    实现接口映射@REstController



35.springboot拦截器
与SpringBootApplication同级目录
创建：TokenInterceptor类
@Component
public class TokenInterceptor implements HandlerInterceptor {

	@Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler){}
}
再创建TokenConfig：
@Configuration
public class TokenConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new TokenInterceptor()).addPathPatterns("/**").excludePathPatterns("/login");
    }
}
注意：这个路径不考虑server.servlet.context-path=/xxx添加的前缀。

@ControllerAdvice
统一异常处理
需要配合@ExceptionHandler使用，当将异常抛到controller时,可以对异常进行统一处理




36.纯Java项目使用HikariCP
Java 8
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>2.7.9</version>
</dependency>

private String url = "jdbc:mysql://127.0.0.1:3306/magnetic?characterEncoding=utf8&useSSL=false";
    private String username = "root";
    private String password = "123456";

    private HikariDataSource ds;

    public void start(){
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(this.url);
        config.setUsername(this.username);
        config.setPassword(this.password);
        config.setDriverClassName("com.mysql.jdbc.Driver");
        //config.setDataSourceClassName();

        //是否自定义配置，为true时下面两个参数才生效
        config.addDataSourceProperty("cachePrepStmts","true");
        //连接池大小默认25，官方推荐250-500
        config.addDataSourceProperty("prepStmtCacheSize","250");
        //单条语句最大长度默认256，官方推荐2048
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        //新版本MySQL支持服务器端准备，开启能够得到显著性能提升
        config.addDataSourceProperty("useServerPrepStmts", "true");
        //池中维护的最小空闲连接数,minimumIdle强烈建议不要配置、默认值与maximumPoolSize相同
        //config.addDataSourceProperty("minimumIdle", "10");
        //池中最大连接数，包括闲置和使用中的连接
        config.addDataSourceProperty("maximumPoolSize", "20");
        //HikariCP将尝试通过仅基于jdbcUrl的DriverManager解析驱动程序，但对于一些较旧的驱动程序，还必须指定driverClassName
        config.addDataSourceProperty("driverClassName", "com.mysql.jdbc.Driver");

        this.ds = new HikariDataSource(config);
    }


报错：java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30000ms.
原因:连接泄漏(在从池中借用之后连接没有关闭)。
hikariDataSource.setIdleTimeout(60000);           //连接允许在池中闲置的最长时间
hikariDataSource.setConnectionTimeout(60000);     //等待来自池的连接的最大毫秒数
hikariDataSource.setValidationTimeout(3000);      //连接将被测试活动的最大时间量
hikariDataSource.setLoginTimeout(5);              //
hikariDataSource.setMaxLifetime(60000);           //池中连接最长生命周期


37.spring缓存方案
有guava cache、redis、tair、memcached等。
Spring Boot默认情况下使用ConcurrentMapCacheManager作为缓存技术。
@Cacheable注解可以使用缓存


38.spring boot定时任务
//表示每个星期1中午5点 "0 0 5 ? * 1"
@Service
public class ScheduledService{
    @Scheduled(cron = "0 0 5 ? * 1")
    public void cronService(){}
}
开启定时任务注解@EnableScheduling
@SpringBootApplication
@EnableScheduling
public class EhomeApplication extends SpringBootServletInitializer{}



39.依赖注入有三种方式：
变量（filed）注入
构造器注入
set方法注入

变量（filed）注入
    @Autowired
    UserDao userDao;

构造器注入
    final
    UserDao userDao;
    @Autowired
    public UserServiceImpl(UserDao userDao) {
        this.userDao = userDao;
    }

set方法注入
    private UserDao userDao;
    @Autowired
    public void setUserDao (UserDao userDao) {
        this.userDao = userDao;
    }

如果这个类使用了依赖注入的类，那么这个类摆脱了这几个依赖必须也能正常运行。然而使用变量注入的方式是不能保证这点的。 
所以变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入。


40.Spring Boot动态定时任务
@Autowired
JdbcTemplate jdbcTemplate;
private ScheduledFuture<?> future; 
future = threadPoolTaskScheduler.schedule(new MyRunnable(), new CronTrigger("0/5 * * * * *"));
private class MyRunnable implements Runnable {
       @Override
       public void run() {
	   String sql = "update CLOCK set isOn = false where clock_id= ?;";
           jdbcTemplate.update(sql,this.clock_id);
           System.out.println("DynamicTask.MyRunnable.run()，" + new Date());
       }
}


41.maven工程连接c3p0
<!-- https://mvnrepository.com/artifact/com.mchange/c3p0 -->
        <dependency>
            <groupId>com.mchange</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.5.2</version>
        </dependency>

    public static ComboPooledDataSource dataSource = new ComboPooledDataSource();
    static {
        try {
            dataSource.setDriverClass("com.mysql.jdbc.Driver");
            dataSource.setJdbcUrl("jdbc:mysql://39.98.182.112:3306/EHome?characterEncoding=utf8&useSSL=false");
            dataSource.setUser("root");
            dataSource.setPassword("uestc@123456");

            //连接池每隔60秒自动检测数据库连接情况，如果断开则自动重连。
            dataSource.setTestConnectionOnCheckin(true);
            dataSource.setIdleConnectionTestPeriod(60);
        } catch (PropertyVetoException e){
            e.printStackTrace();
        }
    }
    public static Connection getConnection(){
        try {
            return dataSource.getConnection();
        }catch (SQLException e){
            e.printStackTrace();
            throw new RuntimeException();
        }
    }


41.spring基础知识
1）POJO
POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。其中有一些属性及其getter setter方法的类,没有业务逻辑。
2）IOC
Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。
谁控制谁，控制什么？
传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建。
为何是反转，哪些方面反转了？
因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。
3）DI—Dependency Injection，即“依赖注入”
那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。
4)AOP
面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP(面向对象)的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。
5）Spring Bean类
Spring Bean是事物处理组件类和实体类（POJO）对象的总称，Spring Bean被Spring IOC容器初始化，装配和管理。
Spring框架几种创建bean的方式：
XML显示配置Bean
<bean class= "man.BigMan" />
通过Java的注解机制来实现的
@Component，@Service和@Constroller
通过Java配置Bean，也是通过注解来实现的，首先要通过@Configuration注解声明一个配置类，该类中应该包含在spring中创建Bean的所有细节，急用@Configuration加上@Bean去注册一个bean对象。



42.springboot整合Hibernate
由于Spring boot默认已经集成了Hibernate, 所在我们只需在pom.xml引用jpa及mysql连接库.
<dependency>  
  <groupId>org.springframework.boot</groupId>  
  <artifactId>spring-boot-starter-data-jpa</artifactId>  
</dependency>  

<dependency>  
  <groupId>mysql</groupId>  
  <artifactId>mysql-connector-java</artifactId>  
</dependency>

spring.jpa.database = MYSQL
//数据库为Mysql
spring.jpa.show-sql = true
//sql语句会输出到控制台
spring.jpa.hibernate.ddl-auto = update
//spring.jpa.properties.hibernate.hbm2ddl.auto=create-drop
//自动创建|更新|验证数据库表结构。如果不是此方面的需求建议设置为"none"，update表示加载hibernate自动更新数据库结构(最常用)。
spring.jpa.hibernate.naming-strategy = org.hibernate.cfg.DefaultNamingStrategy
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect
//在将它们添加到实体管理器之前删除

Hibernate的Annotation注解
一、声明实体
@Entity
对实体注释。任何Hibernate映射对象都要有这个注释
@Table
声明此对象映射到数据库的数据表，通过他可以为实体指定表(Table)，目录(Catalog)和Schema的名字。该注释不是必须的，如果没有则系统使用默认值（实体的短类名）
@Version
该注释可用于在实体Bean中添加乐观锁支持。
二、声明主键
@Id
声明此属性为主键。该属性值可以通过自身创建，但是Hibernate推荐通过Hibernate生成。
@GeneratedValue
指定主键的生成策略。有如下四个值
TABLE：使用表保存id值
IDENTITY：identity column
SEQUENCR：sequence排序
AUTO：根据数据库的不同，使用上面三种
三、声明普通属性
@Column
声明该属性与数据库字段的映射关系

@Query与@Modifying执行更新操作
问题：InstantiationException: No default constructor for entity
注意：hibernate在创建实体类对象时需要一个默认的无参构造函数




43.整合WebSocket
<!-- WebSocket依赖，移除Tomcat容器 -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-websocket</artifactId>
      <exclusions>
        <exclusion>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
      </exclusions>
    </dependency>

基于Stomp的websocket
//注解开启使用STOMP协议来传输基于代理(message broker)的消息,这时控制器支持使用@MessageMapping,就像使用@RequestMapping一样
编写配置文件StompWebsocket:
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer{
@Override
        public void registerStompEndpoints(StompEndpointRegistry registry) {//注册STOMP协议的节点(endpoint),并映射指定的url
            //注册一个STOMP的endpoint,并指定使用SockJS协议
            registry.addEndpoint("/endpointZwj").withSockJS();

        }

        @Override
        public void configureMessageBroker(MessageBrokerRegistry registry) {//配置消息代理(Message Broker)
            //广播式应配置一个/topic消息代理
            registry.enableSimpleBroker("/topic");

        }
}
写Controller
@Controller
    public class WebSocketController {

        @MessageMapping("/welcome") //当浏览器向服务端发送请求时,通过@MessageMapping映射/welcome这个地址,类似于@ResponseMapping
        @SendTo("/topic/getResponse")//当服务器有消息时,会对订阅了@SendTo中的路径的浏览器发送消息
        public AricResponse say(AricMessage message) {
            try {
                //睡眠1秒
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return new AricResponse("welcome," + message.getName() + "!");
        }
    }

客户端使用：
var socket = new SockJS('/endpointAric'); //连接SockJS的endpoint名称为"endpointWisely"
stompClient = Stomp.over(socket);//使用STMOP子协议的WebSocket客户端
stompClient.connect({},function(frame){//连接WebSocket服务端})




44.配置swagger
	<dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.8.0</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.8.0</version>
        </dependency>
创建config文件夹创建Swagger类：
@Configuration
@EnableSwagger2
public class Swagger {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.hibernate.hibernatedemo.controller"))
                .paths(PathSelectors.any())
                .build();
    }
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("springboot利用swagger构建api文档")
                .description("简单优雅的restfun风格，http://blog.csdn.net/wu_zi")
                .termsOfServiceUrl("http://blog.csdn.net/wu_zi")
                .version("1.0")
                .build();
    }
}
创建Controller做测试
@RestController
@RequestMapping("/test")
public class hello {
    @RequestMapping(value = "hello",method = {RequestMethod.POST})
    public String helloWorld(){
        return "helloWorld";
    }
}
访问：
http://localhost:8080/swagger-ui.html


45.lombok
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.6</version>
    <scope>provided</scope>
</dependency>
Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率.帮助写setter,getter。
@Data
会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。
如果觉得@Data太过残暴,可以使用@Getter/@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter/Setter方法:
@Getter @Setter private int age = 10;
@NonNull
该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。
public NonNullExample(@NonNull Person person) {}
@Cleanup
该注解能帮助我们自动调用close()方法，很大的简化了代码。
@Cleanup InputStream in = new FileInputStream(args[0]);
@EqualsAndHashCode
默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过exclude注解来排除一些属性。
@EqualsAndHashCode(exclude={"id", "shape"})
public class EqualsAndHashCodeExample {}
@ToString
类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。
@ToString(exclude="id")
public class ToStringExample {}




46.spring cloud
1）Spring Cloud的核心功能：
分布式/版本化配置
服务注册和发现
路由
服务和服务之间的调用
负载均衡
断路器
2）经常用的5个常用组件
服务发现——Netflix Eureka
客服端负载均衡——Netflix Ribbon
断路器——Netflix Hystrix
服务网关——Netflix Zuul
分布式配置——Spring Cloud Config
分布式消息传递
3）各组件配置使用运行流程：
1、请求统一通过API网关（Zuul）来访问内部服务.
2、网关接收到请求后，从注册中心（Eureka）获取可用服务
3、由Ribbon进行均衡负载后，分发到后端具体实例
4、微服务之间通过Feign进行通信处理业务
5、Hystrix负责处理服务超时熔断
6、Turbine监控服务间的调用和熔断相关指标

Eureka:
Idea：spring initialir -> cloud discovery -> eureka server 



47.tomcat部署多个spring boot项目
spring.jmx.default-domain=proj01
spring.jmx.default-domain=proj02

server.xml
<Context path="/ehome" docBase="/usr/local/tomcat/webapps/ehome" reloadable="true" />
<Context path="/ehomewx" docBase="/usr/local/tomcat/webapps/ehomewx" reloadable="true" />



48.Nexus搭建maven私服
下载：
https://www.sonatype.com/download-oss-sonatype
nexus仓库管理器，分为两个版本，Nexus Repository Manager OSS 和 Nexus Repository Manager Pro。前者可以免费使用，相比后者，功能缺少一些，但是不影响我们搭建maven私服。
下载nexus-3.16.1-02-unix.tar.gz
解压到/usr/local
vim bin/nexus.rc
run_as_user="root" #运行用户为root

vim bin/nexus
INSTALL4J_JAVA_HOME_OVERRIDE=/usr/local/java

vim etc/nexus-default.properties
application-port=10000 #运行端口为10000

添加环境变量：
export NEXUS_HOME=/usr/local/nexus
export PATH=$PATH:$NEXUS_HOME/bin

开机启动：
方法1：
cp /usr/local/nexus/bin/nexus /etc/init.d/nexus
cd /etc/init.d
chkconfig --add nexus
## 设置在3、4、5这3个系统运行级别的时候自动开启nexus服务
sudo chkconfig --levels 345 nexus on

方法2：
使用systemd(CentOS-7推荐使用)
vim /etc/systemd/system/nexus.service
[Unit]
Description=nexus service
After=network.target
[Service]
Type=forking
LimitNOFILE=65536
ExecStart=/usr/local/nexus/bin/nexus start
ExecStop=/usr/local/nexus/bin/nexus stop
User=root
Restart=on-abort
[Install]
WantedBy=multi-user.target

systemctl daemon-reload
#设置开机启动
systemctl enable nexus.service 
systemctl start nexus.service


service nexus start
登录管理页面：
http://192.168.11.206:10000/
管理员默认账户密码为admin/admin123

使用请看：https://cloud.tencent.com/developer/article/1336556





49.异步service
@Service
public class AsynSerivce {
    
    @Async
    public void hello() {
        try {
            Thread.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("处理数据中...");
    }
}

@RestController
public class AsynController {

    @Autowired
    AsynSerivce asynSerivce;

    @GetMapping("/hello")
    public String hello() {
        asynSerivce.hello();
        return "success";
    }
}
当我们访问时，发现我们睡眠的3秒没有起作用，而是直接就执行了这个方法，不会被阻塞在这里异步处理hello请求






50.@Component, @Repository, @Service的区别
在Spring2.0之前的版本中，@Repository注解可以标记在任何的类上，用来表明该类是用来执行与数据库相关的操作（即dao对象），并支持自动处理数据库操作产生的异常
在Spring2.5版本中，引入了更多的Spring类注解：@Component,@Service,@Controller。@Component是一个通用的Spring容器管理的单例bean组件。
而@Repository, @Service, @Controller就是针对不同的使用场景所采取的特定功能化的注解组件。
当你的一个类被@Component所注解，那么就意味着同样可以用@Repository, @Service, @Controller来替代它，同时这些注解会具备有更多的功能，而且功能各异。
最后，如果你不知道要在项目的业务层采用@Service还是@Component注解。那么，@Service是一个更好的选择。






51.@Configuration
@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。
注意：
@Configuration注解的配置类有如下要求：
@Configuration不可以是final类型；
@Configuration不可以是匿名类；
嵌套的configuration必须是静态类。




52.HandlerMethod
HandlerMethod是springMVC中用@Controller声明的一个bean及对应的处理方法.
if(!(object instanceof HandlerMethod)){// 如果不是是SpringMVC Controller请求，直接通过
            return true;
        }



53.isAnnotationPresent, getAnnotation方法, 
指定类型的注释存在于此元素上
A.isAnnotationPresent(B.class)；意思就是：注释B是否在此A上。如果在则返回true；不在则返回false。
getAnnotation 如果存在于此元素，则返回该元素注释指定的注释类型，否则返回为null。
java.lang.reflect.Method.getAnnotation(Class <T> annotationClass)方法如果存在这样的注释，则返回指定类型的元素的注释，否则为null。





54.自定义注解
import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Token {
    String value() default "";
}
自定义注解类编写的一些规则:
1. Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.
2. 参数成员只能用public或默认(default)这两个访问权修饰
3. 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组.
4. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法
5. 注解也可以没有定义成员, 不过这样注解就没啥用了

@Documented 注解
    功能：指明修饰的注解，可以被例如javadoc此类的工具文档化，只负责标记，没有成员取值。
	
@Retention 注解
功能：指明修饰的注解的生存周期，即会保留到哪个阶段。
RetentionPolicy的取值包含以下三种：
SOURCE：源码级别保留，编译后即丢弃。
CLASS:编译级别保留，编译后的class文件中存在，在jvm运行时丢弃，这是默认值。
RUNTIME： 运行级别保留，编译后的class文件中存在，在jvm运行时保留，可以被反射调用。

@Target 注解
功能：指明了修饰的这个注解的使用范围，即被描述的注解可以用在哪里。
ElementType的取值包含以下几种：
TYPE:类，接口或者枚举
FIELD:域，包含枚举常量
METHOD:方法
PARAMETER:参数
CONSTRUCTOR:构造方法
LOCAL_VARIABLE:局部变量
ANNOTATION_TYPE:注解类型
PACKAGE:包

使用
@Token(value="123")或@Token("123")
使用value以外的属性名时，可以不指定属性名称，但其它都必须使用value1="123"形式赋值。



55.获取application配置文件参数的两种方式
application.properties：
zwj.name = zwj
使用@Value方式（常用）
  import org.springframework.beans.factory.annotation.Value;  
  @Value("${test.msg}")  
  private String msg; 
使用ConfigurationProperties
@Component
@ConfigurationProperties(prefix = "person")
 
 @Value不支持复杂类型
 配置文件的占位符：
 application.properties：
 zwj.age = ${random.int}
 
 
56.多项目（如：金证的）
新建个目录把它们都放里面
idea open这个目录；
然后：file->project structure->Modules-> + ->import module->(选中放到这个目录的项目，每个项目都要这么操作一遍)
（项目相互引用是通过pom.xml里面
		<!-- entity实体 -->
        <dependency>
            <groupId>szkingdom.zhcs.kdum_xzyj</groupId>
            <artifactId>xzyj-entity</artifactId>
            <version>1.0.0-SNAPSHOT</version>
        </dependency>

）



57.DO:对应数据库表结构
VO：一般用于前端展示使用
DTO：用于数据传递。（接口入参和接口返回值都可以）
以ssm框架为例：
controller层：
public List<UserVO> getUsers(UserDTO userDto);
Service层：
List<UserDTO> getUsers(UserDTO userDto);
DAO层：
List<UserDTO> getUsers(UserDO userDo);
 
 
 

58.外部jar包集成
 <dependency>
            <groupId>com.jnrsmcu.sdk.netdevice</groupId>
            <artifactId>netdevice</artifactId>
            <version>2.2.2</version>
            <scope>system</scope>
            <systemPath>${project.basedir}/src/main/resources/lib/RSNetDevice-2.2.2.jar</systemPath>
        </dependency>
 <!-- war包添加外部jar包 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-war-plugin</artifactId>
                <configuration>
                    <webResources>
                        <resource>
                            <directory>src/main/resources/lib</directory>
                            <targetPath>WEB-INF/lib/</targetPath>
                            <includes>
                                <include>**/*.jar</include>
                            </includes>
                        </resource>
                    </webResources>
                </configuration>
            </plugin>
  
  
  
  
  
  
 59.@autowired注解原理
 getFields(),获取当前Class所表示类中所有的public的字段
 public Field[] getDeclaredFields():获取当前Class所表示类中所有的字段,不包括继承的字段.
 Method getMethod(String name, Class<?>... parameterTypes)  
返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法
class.getMethods()
该方法是获取本类以及父类或者父接口中所有的公共方法
 
自动装配过程：
1、根据Class对象，通过反射获取所有的Field和```Method````对象
2、通过反射获取Field和Method上的注解，并判断是否有@Autowired和@Value注解（使用到了spring的ReflectionUtils，）
3、将注解了@Autowired和@Value的Field和Method封装成AutowiredFieldElement和AutowiredMethodElement对象，等待下一步的自动装配。
循环处理父类需要自动装配的元素
4、将需要自动装配的元素封装成InjectionMetadata对象，最后合并到Bean定义的externallyManagedConfigMembers属性中
5、用AutowiredFieldElement或AutowiredMethodElement的inject方法，唤起后续步骤
6、通过调用容器的getBean()方法找到需要注入的源数据Bean
7、通过反射将找到的源数据Bean注入到目标Bean中




 
 
 
 
 
60.redis集成
<!--redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <version>2.2.5.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
SpringBoot2.0默认采用Lettuce客户端来连接Redis服务端的
默认是不使用连接池的，只有配置 redis.lettuce.pool下的属性的时候才可以使用到redis连接池
#redis
# Redis数据库索引（默认为0）
spring.redis.database=0
# Redis服务器地址
spring.redis.host=192.168.11.206
#Redis服务器连接端口
spring.redis.port=6379
#Redis服务器连接密码（默认为空）
spring.redis.password=qwertyui
#连接池最大连接数（使用负值表示没有限制）
spring.redis.lettuce.pool.max-active=8
#连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.lettuce.pool.max-wait=10000
#连接池中的最大空闲连接
spring.redis.lettuce.pool.min-idle=3
#连接超时时间（毫秒）
spring.redis.timeout=30000

创建RedisUtil类：
@Component
public class RedisUtil {
    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    private RedisTemplate redisTemplate;

    public String get(String key) {
        String value = (String) stringRedisTemplate.opsForValue().get(key);
        return value;
    }

    public void add(String key, String value) {
        stringRedisTemplate.opsForValue().set(key, value);
    }

    public Object getObj(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    public boolean addObj(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
}
为了使用redisTemplate，需要添加配置：
@Configuration
public class RedisConfig {
    @Bean
    @SuppressWarnings("all")
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();
        template.setConnectionFactory(factory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

        // key采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        // hash的key也采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        // value序列化方式采用jackson
        template.setValueSerializer(jackson2JsonRedisSerializer);
        // hash的value序列化方式采用jackson
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        return template;
    }
}
写一个测试的实体类：
public class RedisBean  {
    String name;
    Integer age;
    public RedisBean() {} // 这是必须的
    public RedisBean(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
}
注：为什么需要空构造函数，redis的这些序列化方式,使用的是无参构造函数进行创建对象set方法进行赋值,
方法中存在有参的构造函数,默认存在的无参构造函数是不存在的(继承自object),必须显示的去重写.

  
  
  
 
 
61.MongoDB集成
<!--mongodb-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
        </dependency>  
#mogodb
spring.data.mongodb.database=xizang
spring.data.mongodb.host=192.168.11.206
spring.data.mongodb.password=sccddw
spring.data.mongodb.username=sccddw
spring.data.mongodb.port=27017
创建RedisUtil类：
@Component
public class MongoUtil {
    @Autowired
    MongoTemplate mongoTemplate;

    public boolean saveObj(Object obj) {
        try {
            mongoTemplate.save(obj);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    public Object getObjById (String id) {
        Query query = new Query(Criteria.where("_id").is(id));
        return mongoTemplate.findOne(query, MongoBean.class);
    }

    public List<MongoBean> findAll () {
        List<MongoBean> list = null;
        try {
            return mongoTemplate.findAll(MongoBean.class);
        } catch (Exception e) {
            e.printStackTrace();
            return list;
        }
    }
}

新建测试类：
@Data
public class MongoBean {
    private String id;
    private String name;
    private String info;
    private Date createTime;

    public MongoBean(String id, String name, String info, Date createTime) {
        this.id = id;
        this.name = name;
        this.info = info;
        this.createTime = createTime;
    }

    @Override
    public String toString() {
        return "id=" + id + ",name=" + name + ",info=" + info + ",createTime" + createTime;
    }
}
注：对象的private属性添加几个getter（、setter）才可以在controller返回给前端。 



  
62.es集成
ES支持两种协议  
       HTTP协议，支持的客户端有Jest client和Rest client
       Native Elasticsearch binary协议，也就是Transport client和Node client
Jest client和Rest client区别
      Jest client非官方支持，在ES5.0之前官方提供的客户端只有Transport client、Node client。在5.0之后官方发布Rest client，并大力推荐.
REST Client
官方推荐使用，所以我们采用这个方式，这个分为两个Low Level REST Client和High Level REST Client，Low Level REST Client是早期出的API比较简陋了，
还需要自己去拼写Query DSL，High Level REST Client使用起来更好用，更符合面向对象的感觉.

<!--rest-->
        <dependency>
            <groupId>org.elasticsearch.client</groupId>
            <artifactId>elasticsearch-rest-client</artifactId>
            <version>7.6.2</version>
        </dependency>
        <dependency>
            <groupId>org.elasticsearch.client</groupId>
            <artifactId>elasticsearch-rest-high-level-client</artifactId>
            <version>7.6.2</version>
        </dependency>
		<dependency>
            <groupId>org.elasticsearch</groupId> (这个需要不然单元测试那会报某些类没有)
            <artifactId>elasticsearch</artifactId>
            <version>7.6.2</version>
        </dependency>
application.properties
spring.elasticsearch.rest.uris=http://127.0.0.1:9200
@Resource
private RestClient client;
或
@Resource
private RestHighLevelClient restHighLevelClient;（推荐）

<!--jest-->
        <dependency>
            <groupId>org.elasticsearch</groupId>
            <artifactId>elasticsearch</artifactId>
            <version>6.5.4</version>
        </dependency>
        <dependency>
            <groupId>io.searchbox</groupId>
            <artifactId>jest</artifactId>
            <version>5.3.3</version>
        </dependency>
application.properties
spring.elasticsearch.jest.uris=http://127.0.0.1:9200
@Resource
private JestClient jestClient;
RestHighLevelClient API:
https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-index.html




63.单元测试无法使用Autowired的解决办法
1）单元测试使用junit4
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>
2）测试类添加
@RunWith(SpringRunner.class)
@SpringBootTest
@Test为import org.junit.Test;
  

  
  
64.socketIO集成：
SocketIOConfig：
@org.springframework.context.annotation.Configuration
public class SocketIOConfig {
    @Value("${socketIo.host}")
    private String host;

    @Value("${socketIo.port}")
    private Integer port;

    @Value("${socketIo.context}")
    private String context;

    @Value("${socketIo.pingTimeout}")
    private int pingTimeout;

    @Bean
    public SocketIOServer socketIOServer() {
        Configuration configuration = new Configuration();
        configuration.setHostname(host);
        configuration.setPort(port);
        configuration.setContext(context);
        configuration.setPingTimeout(pingTimeout);

        return new SocketIOServer(configuration);
    }
}
SocketIOService：
public interface SocketIOService {
    /**
     * 启动服务
     */
    void start();

    /**
     * 停止服务
     */
    void stop();
}
SocketIOServiceImpl：
@Service(value = "SocketIOService")
public class SocketIOServiceImpl implements SocketIOService {
	/**
     * 存放已连接的客户端
     */
    private static Map<String, SocketIOClient> clientMap = new ConcurrentHashMap<>();

    /**
     * 自定义事件`push_data_event`,用于服务端与客户端通信
     */
    private static final String PUSH_DATA_EVENT = "push_data_event";
	// client.sendEvent(PUSH_DATA_EVENT, msgContent); (发送事件)
	
	@Autowired
    private SocketIOServer socketIOServer;

    @Resource
    private ConnectEventListenner connectEventListenner;

    @Override
    public void start() {
        // 监听客户端连接
        socketIOServer.addConnectListener(client -> {
            log.info("************ 客户端： " + getIpByClient(client) + " 已连接 ************");
            // 自定义事件`connected` -> 与客户端通信  （也可以使用内置事件，如：Socket.EVENT_CONNECT）
            client.sendEvent("connected", "你成功连接上了哦...");
            Map params = getParamsByClient(client);
            log.info(params.toString());
        });
        // 监听客户端断开连接
        socketIOServer.addDisconnectListener(client -> {
            String clientIp = getIpByClient(client);
            log.info(clientIp + " *********************** " + "客户端已断开连接");
            Map params = getParamsByClient(client);
            log.info(params.toString());
        });
        // 自定义事件`client_info_event` -> 监听客户端消息
        socketIOServer.addEventListener(PUSH_DATA_EVENT, String.class, (client, data, ackSender) -> {
            // 客户端推送`client_info_event`事件时，onData接受数据，这里是string类型的json数据，还可以为Byte[],object其他类型
            log.info(PUSH_DATA_EVENT + " *********************** " + "事件触发");
            log.info(data);
            String clientIp = getIpByClient(client);
            log.debug(clientIp + " ************ 客户端：" + data);
        });
        // 启动服务
        socketIOServer.start();
    }

    @Override
    public void stop() {
        if (socketIOServer != null) {
            socketIOServer.stop();
            socketIOServer = null;
        }
    }

    /**
     * 获取客户端url中的userId参数（这里根据个人需求和客户端对应修改即可）
     *
     * @param client: 客户端
     * @return: java.lang.String
     */
    private Map getParamsByClient(SocketIOClient client) {
        // 获取客户端url参数（这里的userId是唯一标识）
        Map<String, List<String>> params = client.getHandshakeData().getUrlParams();
        if (!CollectionUtils.isEmpty(params)) {
            return params;
        }
        return null;
    }

    /**
     * 获取连接的客户端ip地址
     *
     * @param client: 客户端
     * @return: java.lang.String
     */
    private String getIpByClient(SocketIOClient client) {
        String sa = client.getRemoteAddress().toString();
        String clientIp = sa.substring(1, sa.indexOf(":"));
        return clientIp;
    }
}  
  
使用CommandLineRunner让socket随springboot启动：
@Component
@Slf4j
public class socketCommandLineRunner implements CommandLineRunner {
    @Autowired
    private SocketIOServiceImpl socketIOService;

    @Override
    public void run(String... args) throws Exception {
        /**
         * 当CommandLineRunner中出现不可预期的异常时，会影响主线程，所以这里单独启动一个线程执行
         */
        new Thread(){
            @Override
            public void run(){
                try {
                    log.info("开始启动");
                    socketIOService.start();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }
}




65.添加阿里maven仓库
idea： file->settings->Maven->user settings file(勾选override)
修改.setting.xml:
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                          https://maven.apache.org/xsd/settings-1.0.0.xsd">

    <mirrors>
        <mirror>
            <id>alimaven</id>
            <name>aliyun maven</name>
            <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
            <mirrorOf>central</mirrorOf>
        </mirror>
    </mirrors>
</settings>



66.文件服务集成
private String filePath = "G:\\";
@PostMapping("/upload")
    @ApiOperation(value="单文件上传")
    public String upload(@RequestParam("file") MultipartFile file) {
        if(file.isEmpty()) {
            return "文件为空";
        }
        String fileName = file.getOriginalFilename();
        String suffixName = fileName.substring(fileName.lastIndexOf("."));
        String uuidName = UUID.randomUUID() + suffixName;
        File dest  = new File(filePath + uuidName);

        try {
            file.transferTo(dest);
            log.info("上传成功");
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "success";
    }

@PostMapping("/multiUpload")
    @ApiOperation(value="多文件上传")
    @ResponseBody
    public String multiUpload(HttpServletRequest request) {
        List<MultipartFile> files = ((MultipartHttpServletRequest) request).getFiles("file");
        for(int i = 0;i<files.size();i++) {
            MultipartFile file = files.get(i);
            if(file.isEmpty()) {
                return "第" + (i++) + "个文件为空";
            }
            String fileName = file.getOriginalFilename();
            File dest  = new File(filePath + fileName);
            try {
                file.transferTo(dest);
                log.info("上传成功");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return "{code: 1, msg: \"123\"}";
    }	
@GetMapping("/download")
    @ApiOperation(value="文件下载")
    public ResultInfo downloadFile(@RequestParam("fileName") String fileName, HttpServletResponse response) {
        ResultInfo resultInfo = new ResultInfo();
        File file = new File(filePath + fileName);
        try {
            FileInputStream fileInputStream = new FileInputStream(file);
//            response.setContentType("application/force-download");
            response.addHeader("Content-disposition", "attachment;fileName=" + fileName);
            OutputStream outputStream = response.getOutputStream();

            byte[] buf = new byte[1024];
            int len = 0;
            while ((len = fileInputStream.read(buf)) != -1) {
                outputStream.write(buf, 0, len);
            }
            fileInputStream.close();
            resultInfo.setResultCode(ResultCode.SUCCESS);
            resultInfo.setData("success");
            return resultInfo;
        } catch (IOException e) {
            e.printStackTrace();
        }
        resultInfo.setResultCode(ResultCode.FILE_ERROR);
        return resultInfo;
    }
springboot上传文件大小限制：
spring.servlet.multipart.max-file-size=5000MB
spring.servlet.multipart.max-request-size=5000MB



67.profiles多环境切换
新建文件
application-206.properties
在application.properties添加：
spring.profiles.active=206
yml文档块写法：
server
	port: 8080
spring:
	profiles:
		active: dev
---
server
	port: 8081
spring
	profiles: dev
命令行方式：
java -jar --spring-profiles.active=dev;



68.springboot配置文件加载顺序
-file:./config
-file:./
-classpath:/config/
-classpath:/
各个配置文件是互补的
命令行指定：
java -jar xxx--spring.config.location=G:/application-dev.properties

springboot debug模式：
application.properties:
debug=true
控制台会打印启用的自动配置类
springboot2的application.properties 官方配置 说明文件：
https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/html/appendix-application-properties.html#common-application-properties


69.Autowired与Resource
@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。
@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。
所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。
(类型就是类UserDao，name就是@Resource(name="baseDao"))
@Resource
如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找。如果注解写在setter方法上默认取属性名进行装配。
当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。
@Qualifier("service")
@Qualifier注解了，qualifier的意思是合格者，通过这个标示，表明了哪个实现类才是我们所需要的
一般@Autowired和@Qualifier一起用，@Resource单独用。当然没有冲突的话@Autowired也可以单独用




70.myBatis集成
创建mapper
1）使用注解
@SpringBootApplication上添加@MapperScan("com.sccddw.iot.mapper")指定mapper包批量扫描，就不用每个类加@Mapper
创建mapper目录
创建xxxMpper接口文件：
@Mapper
public interface SDSensorTypeMapper extends BaseMapper<SDSensorType> {
    @Select("select * from sd_sensor_type;")
    List<SDSensorType> findAll();
}
创建service目录
创建IxxxService
public interface IxxxService {
    List<SDSensorType> findAll();
}
在service目录中创建impl目录
新建DmServiceImpl
@Service
public class xxxServiceImpl implements IxxxService {
    @Autowired
    xxxMapper xxxMapper;

    public List<Dm> findAll () {
        return xxxMapper.findAll();
    }
}


2）使用新xml
# mybatis-plus
#全局配置文件
mybatis-plus.config-locations=classpath:mybatis/mybatis-config.xml
#mybatis-plus.type-aliases-package=com.sccddw.test.entity.vo,com.sccddw.test.entity.db,com.sccddw.test.entity.bean
# 指定sql映射文件的位置
mybatis-plus.mapper-locations=classpath:mybatis/mapper/*.xml
mybatis-plus.global-config.db-config.id-type=auto
在resources中创建mybatis目录
创建：mybatis-config.xml
在mybatis目录下创建mapper目录：
单个：DrsrsAllocateDepotOrderDetailMapper.xml





71.shiro集成
<!--shiro-->
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-spring</artifactId>
            <version>1.5.3</version>
        </dependency>
shiro功能：
    认证、授权、加密、会话管理





72.@tableid
mybatis主键注解



71.oauth2
四种模式：
授权码模式（authorization code）
    网上看到通过微信登录，QQ登录等字眼。通过请求获取授权code，response_type:code（授权码模式下springOAuth2规定为code）;
redirect_uri:授权成功后的回调地址，登录成功后会去到redirect_uri并带上code.然后拿code去鉴权服务拿token。
    对于认证中心：需要注册用户，需要注册应用。
简化模式（implicit）

密码模式（resource owner password credentials）
    主要是适用于客户端来获取用户信息的场景。
	与授权码模式不同，不需要认证服务颁发的授权码，只需要用户名和密码以及我们设置的客户端信息就可以了。
	
客户端模式（client credentials）(主要用于api认证，跟用户无关)
提供给第三方一个client_id 和 client_secret,相当于公用的用户名密码,第三方拿着这俩东西去换取令牌,拿着令牌去取数据就可以了. 
基本只需要提供两个接口 ,  一个是获取令牌 , 一个是获取数据
GET /token?grant_type=client_credentials & client_id = {客户端身份ID} &  相当于用户名client_secret = {客户端秘钥}  & 相当于密码
我们后端拿着这个用户名密码进行比对 , 比对成功 ,返回access_token
2. 第三方拿着access_token 获取数据
GET /user?access_token = {令牌} &uid = {用户ID}
后端验证access_token 存在 , 并且没有过期 , 就验证通过 , 返回数据。







































  